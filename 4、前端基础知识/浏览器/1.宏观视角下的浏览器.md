## 🌺 01 chrome架构：仅仅打开了一个页面，为什么有四个进程？



> 文章：https://time.geekbang.org/column/article/113513



个人理解整理过后的笔记。



1. chrome浏览器打开一个页面，为什么要启动四个进程呢？

   我们需要明确 进程 和 线程 的区别，在此之前，需要了解什么是 并行处理，可以帮助我们更好理解 进程 和 线程。

   `并行处理`：同一时刻处理多个任务。多线程 与 单线程 相比，可以大大提升性能。

   `进程`：启动一个程序时，操作系统为该程序创建一块内存，用于存放代码、运行中的数据和一个执行任务的主线程。这样一个运行环境叫做进程。

   `线程`：依附于进程，无法单独存在，由进程来启动和管理，进程中使用多线程并行处理能提升运算效率。

   进程和线程之间的关系有以下4个特点：

   * 进程中的任一线程出错，都会导致整个进程的崩溃
   * 线程之间共享进程中的数据
   * 一个进程关闭后，操作系统会回收进程所占用的内存，包括其中线程操作不当而引发的内存泄漏
   * 进程之间的内容相互严格隔离，如果进程之间想通讯，就需要用到 IPC 机制了



2. 浏览器的单进程时代到如今的多进程时代

   顾名思义，`单进程浏览器`是指浏览器的所有功能模块都是运行在同一个进程里。这些模块包括网络、插件、JS运行环境、渲染引擎、页面等。2007年之前，所有的浏览器都是单进程的。

   因此，单进程浏览器有如下缺点：

   * 不稳定：一个插件的崩溃会引起整个浏览器的崩溃

   * 不流畅：无限循环脚本、插件、页面的内存泄漏都是不流畅的原因

   * 不安全：恶意插件、恶意脚本获取系统权限等

     

   `多进程浏览器`时代，不同的任务交给不同的进程来完成，进程之间通过 IPC 进行通信，故很好解决了如上三个问题：

   * 稳定性：单个进程崩溃不会影响别的进程，不会影响别的页面和浏览器
   * 流畅性：无限循环脚本影响的只是自己的页面，不会影响别的页面，而内存泄漏时关闭整个页面，该进程所占用的内存都会被回收
   * 安全性：安全沙箱，沙箱里面的程序可以运行，但是无法在硬盘上写入任何数据，也不能在敏感位置读取任何数据。恶意程序无法突破沙箱去获取系统权限。



3. 浏览器中不同进程的作用分别是什么？打开一个页面至少需要几个进程？

   * 浏览器进程：负责页面显示、用户交互、子进程管理、存储功能

   * 渲染进程：将 HTML CSS JS 转换为用户可以交互的网页，排版引擎和V8引擎都是运行在该进程中，默认每个 Tab 栏都有一个渲染进程，且运行在沙箱模式下

   * GPU进程：最初为了 3D CSS 效果，后来用于绘制 UI 界面

   * 网络进程：负责页面的网络资源加载，之前在浏览器进程中

   * 插件进程：负责插件的运行，插件易崩溃，需要该进程来隔离

     

   打开一个页面至少需要4个进程，分别是：

   * 网络进程
   * 浏览器进程
   * GPU进程
   * 渲染进程



4. 多进程架构的缺点

   * 更高的资源占用
   * 更复杂的体系结构

   为此，chrome团队提出了 SOA ，即面向服务的架构，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统。











## ✈️ 02 TCP协议：如何保证页面文件能被完整送达浏览器？



> 文章：https://time.geekbang.org/column/article/113550
>
> 
>
> 一个文件通常会被拆为很多数据包来发送，怎样保证文件能完整送达呢？
>
> 互联网中的数据是通过数据包来传输的，如果文件很大，那么文件会被拆分为很多小的数据包来传输。我们先来理解几个概念：



个人理解整理后的笔记



1. IP

   `IP`：计算机的地址。互联网上不同的在线设备都有唯一的地址，是一串数字，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。

   

   下图就是一个数据包从主机 A 到 主机 B 的过程

   ![](https://static001.geekbang.org/resource/image/00/4d/00d9bcad0bda1fdb43ead428e89ae74d.png?wh=1142*703)

   

2. UDP

   `UDP`：数据包送达应用程序。IP协议 是非常底层的协议，只负责把数据包发送给对方电脑，但是对方电脑并不知道把数据包交给哪个程序。UDP协议就是干这个的。UDP中一个重要信息就是 端口号。IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序。

   

   下图为UDP网络四层传输模型

   ![](https://static001.geekbang.org/resource/image/3e/ea/3edb673a43f23d84253c52124ce447ea.png?wh=1142*814)

   

   UDP的问题：对于错误的数据包，不提供重发机制，进而也就无法保证数据的可靠性，但是它的传输速度却非常快，可以应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。

   

3. TCP

   对于浏览器请求和邮件这类要求数据可靠性的应用，如果我们通过 UDP 来传输会有两个问题：1、数据包容易丢失； 2、数据包拆分之后的顺序无法还原

   因此我们引出了 `TCP`：面向连接的、可靠的，基于字节流的传输层通信协议。

   有以下两个特点：

   * 对于数据包丢失的情况，TCP 提供了重连机制
   * TCP 引入了数据包排序机制，用来把打乱的数据包组合成一个完整的文件

   下图表示了 TCP 的单个数据包的传输流程：

   

   ![](https://static001.geekbang.org/resource/image/94/32/943ac29f7d5b45a8861b0cde5da99032.png?wh=1142*798)

   通过上图我们可以看到，TCP协议 和 UDP协议 一样，都是属于传输层的协议，只不过两者的适用场景不同。

   

4. 完整的 TCP 连接过程

   ![](https://static001.geekbang.org/resource/image/44/44/440ee50de56edc27c6b3c992b3a25844.png?wh=1142*408)

   

   一个完整的 TCP 连接的生命周期包括了 “建立连接” “传输数据” “断开连接”

   * 建立连接阶段：三次握手指的是客户端和服务器总共要发送三个数据包以确认连接的建立
   * 传输数据阶段：接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。当接收到所有数据包后，按照TCP头中的序号为其排序，从而保证组成完整的数据。
   * 断开连接阶段：四次挥手断开连接









## 🚀 03 HTTP请求流程：为什么很多站点二次打开会很快？



> 文章：https://time.geekbang.org/column/article/116588
>
> http协议，正是建立在 TCP 连接基础上的。http 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础。



个人笔记



1. 浏览器端发起 HTTP 请求流程

   * 构建请求

   * 查找缓存

   * 准备 IP 地址和端口

   * 等待 TCP 队列

   * 建立 TCP 连接

   * 发送 HTTP 请求

     

2. 服务器端处理 HTTP 请求流程

   1. 返回请求

   2. 断开连接

   3. 重定向

      

3. 为什么很多站点二次打开速度会很快？

   因为在第一次加载页面的过程中，缓存了一些耗时的数据，如：DNS、页面资源

   这些缓存在本地的内容就会回应请求，而不会产生真实的网络请求，从而节省了时间。

   

4. 🚀 登录状态是如何保持的？

   如果服务器端发送的响应头内有 set-cookie 字段，那么浏览器会将该字段的内容保存在本地。当下次客户端往该服务器发送请求时，客户端会自动在请求头中加入 cookie 的值后再发送出去。服务器端发现客户端发送过来的 cookie 后，会去检查究竟是从哪一个客户端发来的连接请求🔗，然后对比服务器上的记录，最后得到该用户的状态信息。



http请求流程示意图：

![](https://static001.geekbang.org/resource/image/1b/6c/1b49976aca2c700883d48d927f48986c.png?wh=1142*423)











## 🔥 04 导航流程：从输入 URL 到页面展示，中间发生了什么？



> 文章：https://time.geekbang.org/column/article/117637
>
> 
>
> 用户发出 url 请求到页面开始解析的这个过程，叫做导航。
>
> 导航流程很重要，它是网络加载流程和渲染流程之间的一座桥梁，如果你理解了导航流程，那么你就能完整串起来整个页面显示流程，这对于你理解浏览器的工作原理起到了点睛的作用。



整个流程如下图所示：

![](https://static001.geekbang.org/resource/image/92/5d/92d73c75308e50d5c06ad44612bcb45d.png?wh=1142*478)



| 文字描述                                                     |
| ------------------------------------------------------------ |
| 1. 首先，浏览器进程收到用户输入的url请求，浏览器进程将该url转发给网络进程； |
| 2. 然后，在网络进程中发起真正的url请求；                     |
| 3. 接着，网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程； |
| 4. 浏览器进程接收到网络进程的响应头数据之后，发送“提交导航”消息到渲染进程； |
| 5. 渲染进程收到后，开始准备接收html数据，方式是直接和网络进程建立数据管道； |
| 6. 渲染进程向浏览器进程“确认提交”，这是告诉浏览器进程“已经准备接受和解析页面数据了” |
| 7. 浏览器进程接收到渲染进程的“提交”消息后，开始移除之前的文档，然后更新浏览器进程中的页面状态。 |



1. 用户输入

   用户在地址栏中输入了字符，地址栏会判断这是搜索内容还是请求的url，如果是搜索内容，就会用默认的搜索引擎来合成带搜索关键字的url。如果地址栏判断内容符合url规则，如 time.geekbang.org ，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 url ：http://time.geekbang.org/

   

   当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 beforeunload 事件的机会，beforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。

   （一个典型例子就是知乎网页版，点击一个链接时，会提示是否跳转其他外部页面？这就是监听了页面的 beforeunload 事件）

   

   如果页面没有监听 beforeunload 事件或者同意了后续流程，那么标签页左边就会开始转圈圈，但是页面内容依然是之前打开的内容，只有等待提交文档阶段，页面才会被替换。

   

2. url 请求过程

   此时进入了页面资源请求过程。这时浏览器进程会通过进程间通讯 IPC 把 url 请求发送到网络进程，网络进程收到 url 请求后，会在这里发起真正的 url 请求流程，具体如下：

   

   查缓存--->如果有，直接返回

   ​	 --->如果没有--->DNS解析--->如果是https，还要建立TLS连接--->网络请求流程--->利用ip地址和服务器建立TCP连接 --> 浏览器构建请求头等信息向服务器发送 --> 服务器接受，生成响应头数据，发给网络进程 --> 网络进程开始解析响应头 ---> 如果状态码为301/302那么就会进行重定向--->如果状态码为200那浏览器可继续处理该请求--->根据content-type字段决定返回什么内容--->如果该字段HTML那么就会进行渲染流程

   

3. 准备渲染过程

   一般情况下，每个页面都有一个渲染进程，但是某些情况下会出现多个页面运行在一个渲染进程中，什么情况呢？答案是同一站点。

   

   什么是同一站点？

   根域名加上协议，还包含该根域名下所有子域名和不同的端口，如下三个就属于同一站点

   ```js
   https://time.geekbang.org
   https://www.geekbang.org
   https://www.geekbang.org:8080
   ```

   它们协议相同，根域名都为 geekbang.org

   

   chrome默认每一个页面对应一个渲染进程，**但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程**（此时有个例外，⚠️如果标签中有 rel="noopener noreferrer" 这个属性，就是告诉浏览器新子窗口不需要访问父窗口的任何内容，防止钓鱼网站窃取父窗口信息）

   

   渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。

   

4. 提交文档

   这个阶段是🈯️浏览器进程将网络进程接收到的HTML数据提交给渲染进程，具体如下：

   1. 浏览器进程接收到网络进程的响应头数据，向渲染进程发起“提交文档”消息
   2. 渲染进程接收到后，和网络进程建立传输数据的管道
   3. 等文档数据传输完成，渲染进程返回“确认提交”信息给浏览器进程
   4. 浏览器进程给你接收到后，更新浏览器界面状态，包括安全状态、地址栏URL、前进后退的历史状态，并更新web页面

   

   这也解释了浏览器地址栏中输入一个地址后，之前的页面没有立马消失，而是加载一会才更新页面，到此，一个完整的导航流程就走完了，之后就进入到了渲染阶段。

   

5. 渲染阶段

   后续详细分析

   只需要知道一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。







## 🌍 05 渲染流程：HTML、CSS、JS是如何变成页面的？

> 课程地址：https://time.geekbang.org/column/article/118205
>
> https://time.geekbang.org/column/article/118826
>
> 这个阶段很重要，了解其相关流程能让你“看透”页面是如何工作的，有了这些知识，你可以解决一系列相关的问题，比如能熟练使用开发者工具，因为能够理解开发者工具里面大部分项目的含义，能优化页面卡顿问题，使用 JavaScript 优化动画流程，通过优化样式表来防止强制同步布局，等等。
>
> 渲染机制过于复杂，我们可以分为几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化、合成。
>
> 我们需要关注每个阶段的如下过程：输入、处理、输出，可以帮助我们更好掌握这些阶段。



1. 构建 DOM 树🌲

   ➡️ 输入：HTML

   ➡️ 操作：HTML解析

   ➡️ 输出：DOM树

   

   DOM 树可以理解为一种浏览器可以理解的数据结构，用来表示 HTML 中的层级结构。

   

   DOM 和 HTML 几乎是一样的内容，但是和 HTML 不同的是，DOM 是保存在内存中的树状结构，可以通过 JS 来查询和修改。如：

   `document.getElementsByTagName("p")[0].innerText = "black"`

   

   当我们拥有了 DOM 树，还需要 DOM 节点有正确的样式，这下就需要样式计算

   

2. 样式计算 Recalculate Style

   ➡️ 输入：css 文本

   ➡️ 操作：转换操作（先转化为styleSheets——属性标准化——计算） 

   ➡️ 输出：每个元素的具体样式，保存在 ComputedStyle 结构里

   

   样式计算的目的就是：计算 DOM 节点中每个元素的具体样式

   

   css的来源有三个：link引用、《style》标记内、行内样式

   当渲染引擎接受 css 文本后会执行一个转换操作，将 css 文本转换为浏览器可以理解的解构——**styleSheets**. 我们可以通过  `documents.styleSheets` 来访问。该结构具备了**查询**和**修改**功能，这为我们后面操作样式提供了基础。

   

   随后我们需要进行**属性标准化**，如下：

   ![](https://static001.geekbang.org/resource/image/12/60/1252c6d3c1a51714606daa6bdad3a560.png?wh=1142*346)

   

   标准化完成之后，我们需要计算每个节点的具体样式，如何计算呢？

   通过 css 的继承规则和层叠规则来计算

   其中 css 继承🈯️每个 DOM 节点都包含父节点的样式。

   而层叠是🈯️ 找出一个给定元素的所有声明后，先按显式权重和来源进行排序。如果相同，则比较特殊性。若再相同，则比较顺序。它是css 的一个基本特征，它的全名就叫“层叠样式表”，位于 css 的核心地位。

   

3. 布局阶段

   ➡️ 输入：DOM 和 ComputedStyle

   ➡️ 操作：创建布局树 布局计算

   ➡️ 输出：布局树（把布局计算后结果加入后的）

   

   我们现在有了 DOM 和 DOM 树中元素的样式，还不足显示页面，因为我们不知道 DOM 元素的几何位置，我们计算 DOM 几何位置的过程叫**布局**。基本过程如下：

   ![](https://static001.geekbang.org/resource/image/8e/0e/8e48b77dd48bdc509958e73b9935710e.png?wh=1142*984)

   我们可以看到，DOM 中可能会存在一些不可见的标签或者 display：none 的元素，我们在显示之前，需要额外构建一棵只包含可见元素的**布局树**。

   

   现在我们有了布局树，接下来进行布局树节点的坐标位置了，该过程非常复杂，先略过，最终，布局计算的结果会被重新写回布局树中。

   

4. 分层 ⛺️

   ➡️ 输入：特定的节点

   ➡️ 操作：生成

   ➡️ 输出：图层树

   

   我们有了布局树，也知道了每个元素的位置，是否可以开始着手绘制页面了？ 答案是否定的。因为页面中有许多复杂的效果，如 3D 变换，页面滚动，z轴排序等，为了实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，生成一颗图层树🌲（layerTree）

   图层树和布局树的关系如下：

   ![](https://static001.geekbang.org/resource/image/e8/61/e8a7e60a2a08e05239456284d2aa4061.png?wh=1142*674)

   

   可以看到，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。

   那么问题来了，通常需要满足什么条件才会单独成为一个图层呢？ 答案是满足以下两点中任一点即可：

   * 拥有层叠上下文属性的元素会被提升为单独的一层，如有定位属性的元素，透明属性的元素，css滤镜的元素等

   * 需要裁剪的地方会被创建为图层，如文字超过现实区域或出现滚动条的地方

     

5. 图层绘制 🖌

   ➡️ ：图层树🌲

   ➡️ ：把一个图层的绘制拆分为很多小的绘制指令，将其按照顺序组成一个绘制列表

   ➡️ ：待绘制列表

   

   完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制。

   那么，是如何绘制的呢？ 

   渲染引擎会把一个图层的绘制拆分为很多小的绘制指令，然后将这些指令按照顺序组成一个绘制列表，如下图

   ![](https://static001.geekbang.org/resource/image/40/08/40825a55214a7990bba6b9bec6e54108.png?wh=1142*603)

   绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以这个阶段的输出就是这些待绘制列表。

   

6. 栅格化（raster）操作

   ➡️ 输入：待绘制列表

   ➡️ 操作：主线程把 待绘制列表 提交给 合成线程，合成线程将图层划分为图块后，优先将视口附近图块生成为位图（生成过程为栅格化操作，由GPU进程执行）

   ➡️ 输出：视口部分图块的位图（保存在 GPU 内存中）

   

   绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际的绘制操作是渲染引擎中的合成线程来完成，当图层的绘制列表准备好之后，主线程会把绘制列表提交给合成线程，那么合成线程是如何工作的呢？

   通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做**视口**（viewport）。因为用户看到的只是视口的内容，如果把一个大图层全部绘制的话会产生很大的开销，而且也没有必要，基于此，合成线程会将图层划分为图块（tile），然后合成线程会按照视口附近的图块优先生成位图，实际生成位图的操作是由栅格化来执行的，所谓栅格化，是🈯️将图块转换为位图。图块也是栅格化执行的最小单位，渲染进程维护了一个栅格化的线程池，所有图块栅格化都是在线程池内执行的，如下所示：

   ![](https://static001.geekbang.org/resource/image/d8/20/d8d77356211e12b47bb9f508e2db8520.png?wh=1142*677)

   

   通常，栅格化过程都会用 GPU 来加速生成，这个过程也叫快速栅格化或 GPU 栅格化，生成的位图被保存在 GPU 内存中。这个过程中涉及到了跨进程操作，从渲染进程到GPU进程。

   

7. 合成和显示

   ➡️ 输入：所有被光栅化的图块

   ➡️ 操作：合成线程就会生成一个绘制图块的命令——“DrawQuad”并发送给浏览器进程，viz 组件将其页面内容绘制到内存中，最后再将内存显示在屏幕上

   ➡️ 输出：页面

   

   一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

   浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

   

   到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。

   

8. 总结

   完整渲染流水线示意图：

   ![](https://static001.geekbang.org/resource/image/97/37/975fcbf7f83cc20d216f3d68a85d0f37.png?wh=1142*745)

   文字表述如下：

   * 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。

   * 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。

   * 创建布局树，并计算元素的布局信息。

   * 对布局树进行分层，并生成分层树。

   * 为每个图层生成绘制列表，并将其提交到合成线程。

   * 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。

   * 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。

   * 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

   

   还需要理解一些重要概念，对性能优化有很大帮助：

   

   重排：🈯️更新元素的几何属性。如用 js 或 css 修改元素的宽度高度等，这时就会触发重新布局、解析之后的一系列子阶段，它会更新完整的渲染流水线，开销最大。

   ![](https://static001.geekbang.org/resource/image/b3/e5/b3ed565230fe4f5c1886304a8ff754e5.png?wh=1142*318)

   

   重绘：🈯️更新元素的绘制属性。如用 js 更改元素的背景颜色，那么布局阶段将不会被执行，因为没有引起几何位置的变换，所以就直接进入了绘制阶段以及之后的一系列子阶段。相较于重排，重绘省去了布局和分层阶段，执行效率比重排要高

   ![](https://static001.geekbang.org/resource/image/3c/03/3c1b7310648cccbf6aa4a42ad0202b03.png?wh=1142*286)

   

   合成：🈯️直接合成阶段。如使用 css 的 transform 来实现动画效果，可以避开重排和重绘，直接在非主线程上执行合成动画操作，效率最高，因为没有占用主线程的资源。

   ![](https://static001.geekbang.org/resource/image/02/2c/024bf6c83b8146d267f476555d953a2c.png?wh=1142*270)



