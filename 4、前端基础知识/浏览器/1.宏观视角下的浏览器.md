## 🌺 01 chrome架构：仅仅打开了一个页面，为什么有四个进程？



> 文章：https://time.geekbang.org/column/article/113513



个人理解整理过后的笔记。



1. chrome浏览器打开一个页面，为什么要启动四个进程呢？

   我们需要明确 进程 和 线程 的区别，在此之前，需要了解什么是 并行处理，可以帮助我们更好理解 进程 和 线程。

   `并行处理`：同一时刻处理多个任务。多线程 与 单线程 相比，可以大大提升性能。

   `进程`：启动一个程序时，操作系统为该程序创建一块内存，用于存放代码、运行中的数据和一个执行任务的主线程。这样一个运行环境叫做进程。

   `线程`：依附于进程，无法单独存在，由进程来启动和管理，进程中使用多线程并行处理能提升运算效率。

   进程和线程之间的关系有以下4个特点：

   * 进程中的任一线程出错，都会导致整个进程的崩溃
   * 线程之间共享进程中的数据
   * 一个进程关闭后，操作系统会回收进程所占用的内存，包括其中线程操作不当而引发的内存泄漏
   * 进程之间的内容相互严格隔离，如果进程之间想通讯，就需要用到 IPC 机制了



2. 浏览器的单进程时代到如今的多进程时代

   顾名思义，`单进程浏览器`是指浏览器的所有功能模块都是运行在同一个进程里。这些模块包括网络、插件、JS运行环境、渲染引擎、页面等。2007年之前，所有的浏览器都是单进程的。

   因此，单进程浏览器有如下缺点：

   * 不稳定：一个插件的崩溃会引起整个浏览器的崩溃

   * 不流畅：无限循环脚本、插件、页面的内存泄漏都是不流畅的原因

   * 不安全：恶意插件、恶意脚本获取系统权限等

     

   `多进程浏览器`时代，不同的任务交给不同的进程来完成，进程之间通过 IPC 进行通信，故很好解决了如上三个问题：

   * 稳定性：单个进程崩溃不会影响别的进程，不会影响别的页面和浏览器
   * 流畅性：无限循环脚本影响的只是自己的页面，不会影响别的页面，而内存泄漏时关闭整个页面，该进程所占用的内存都会被回收
   * 安全性：安全沙箱，沙箱里面的程序可以运行，但是无法在硬盘上写入任何数据，也不能在敏感位置读取任何数据。恶意程序无法突破沙箱去获取系统权限。



3. 浏览器中不同进程的作用分别是什么？打开一个页面至少需要几个进程？

   * 浏览器进程：负责页面显示、用户交互、子进程管理、存储功能

   * 渲染进程：将 HTML CSS JS 转换为用户可以交互的网页，排版引擎和V8引擎都是运行在该进程中，默认每个 Tab 栏都有一个渲染进程，且运行在沙箱模式下

   * GPU进程：最初为了 3D CSS 效果，后来用于绘制 UI 界面

   * 网络进程：负责页面的网络资源加载，之前在浏览器进程中

   * 插件进程：负责插件的运行，插件易崩溃，需要该进程来隔离

     

   打开一个页面至少需要4个进程，分别是：

   * 网络进程
   * 浏览器进程
   * GPU进程
   * 渲染进程



4. 多进程架构的缺点

   * 更高的资源占用
   * 更复杂的体系结构

   为此，chrome团队提出了 SOA ，即面向服务的架构，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统。











## ✈️ 02 TCP协议：如何保证页面文件能被完整送达浏览器？



> 文章：https://time.geekbang.org/column/article/113550
>
> 
>
> 一个文件通常会被拆为很多数据包来发送，怎样保证文件能完整送达呢？
>
> 互联网中的数据是通过数据包来传输的，如果文件很大，那么文件会被拆分为很多小的数据包来传输。我们先来理解几个概念：



个人理解整理后的笔记



1. IP

   `IP`：计算机的地址。互联网上不同的在线设备都有唯一的地址，是一串数字，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。

   

   下图就是一个数据包从主机 A 到 主机 B 的过程

   ![](https://static001.geekbang.org/resource/image/00/4d/00d9bcad0bda1fdb43ead428e89ae74d.png?wh=1142*703)

   

2. UDP

   `UDP`：数据包送达应用程序。IP协议 是非常底层的协议，只负责把数据包发送给对方电脑，但是对方电脑并不知道把数据包交给哪个程序。UDP协议就是干这个的。UDP中一个重要信息就是 端口号。IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序。

   

   下图为UDP网络四层传输模型

   ![](https://static001.geekbang.org/resource/image/3e/ea/3edb673a43f23d84253c52124ce447ea.png?wh=1142*814)

   

   UDP的问题：对于错误的数据包，不提供重发机制，进而也就无法保证数据的可靠性，但是它的传输速度却非常快，可以应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。

   

3. TCP

   对于浏览器请求和邮件这类要求数据可靠性的应用，如果我们通过 UDP 来传输会有两个问题：1、数据包容易丢失； 2、数据包拆分之后的顺序无法还原

   因此我们引出了 `TCP`：面向连接的、可靠的，基于字节流的传输层通信协议。

   有以下两个特点：

   * 对于数据包丢失的情况，TCP 提供了重连机制
   * TCP 引入了数据包排序机制，用来把打乱的数据包组合成一个完整的文件

   下图表示了 TCP 的单个数据包的传输流程：

   

   ![](https://static001.geekbang.org/resource/image/94/32/943ac29f7d5b45a8861b0cde5da99032.png?wh=1142*798)

   通过上图我们可以看到，TCP协议 和 UDP协议 一样，都是属于传输层的协议，只不过两者的适用场景不同。

   

4. 完整的 TCP 连接过程

   ![](https://static001.geekbang.org/resource/image/44/44/440ee50de56edc27c6b3c992b3a25844.png?wh=1142*408)

   

   一个完整的 TCP 连接的生命周期包括了 “建立连接” “传输数据” “断开连接”

   * 建立连接阶段：三次握手指的是客户端和服务器总共要发送三个数据包以确认连接的建立
   * 传输数据阶段：接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。当接收到所有数据包后，按照TCP头中的序号为其排序，从而保证组成完整的数据。
   * 断开连接阶段：四次挥手断开连接









## 🚀 03 HTTP请求流程：为什么很多站点二次打开会很快？



> 文章：https://time.geekbang.org/column/article/116588
>
> http协议，正是建立在 TCP 连接基础上的。http 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础。



个人笔记



1. 浏览器端发起 HTTP 请求流程

   * 构建请求

   * 查找缓存

   * 准备 IP 地址和端口

   * 等待 TCP 队列

   * 建立 TCP 连接

   * 发送 HTTP 请求

     

2. 服务器端处理 HTTP 请求流程

   1. 返回请求

   2. 断开连接

   3. 重定向

      

3. 为什么很多站点二次打开速度会很快？

   因为在第一次加载页面的过程中，缓存了一些耗时的数据，如：DNS、页面资源

   这些缓存在本地的内容就会回应请求，而不会产生真实的网络请求，从而节省了时间。

   

4. 🚀 登录状态是如何保持的？

   如果服务器端发送的响应头内有 set-cookie 字段，那么浏览器会将该字段的内容保存在本地。当下次客户端往该服务器发送请求时，客户端会自动在请求头中加入 cookie 的值后再发送出去。服务器端发现客户端发送过来的 cookie 后，会去检查究竟是从哪一个客户端发来的连接请求🔗，然后对比服务器上的记录，最后得到该用户的状态信息。



http请求流程示意图：

![](https://static001.geekbang.org/resource/image/1b/6c/1b49976aca2c700883d48d927f48986c.png?wh=1142*423)











## 🔥 04 导航流程：从输入 URL 到页面展示，中间发生了什么？



> 文章：https://time.geekbang.org/column/article/117637
>
> 
>
> 用户发出 url 请求到页面开始解析的这个过程，叫做导航。



整个流程如下图所示：

![](https://static001.geekbang.org/resource/image/92/5d/92d73c75308e50d5c06ad44612bcb45d.png?wh=1142*478)



| 文字描述                                                     |
| ------------------------------------------------------------ |
| 1. 首先，浏览器进程收到用户输入的url请求，浏览器进程将该url转发给网络进程； |
| 2. 然后，在网络进程中发起真正的url请求；                     |
| 3. 接着，网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程； |
| 4. 浏览器进程接收到网络进程的响应头数据之后，发送“提交导航”消息到渲染进程； |
| 5. 渲染进程收到后，开始准备接收html数据，方式是直接和网络进程建立数据管道； |
| 6. 渲染进程向浏览器进程“确认提交”，这是告诉浏览器进程“已经准备接受和解析页面数据了” |
| 7. 浏览器进程接收到渲染进程的“提交”消息后，开始移除之前的文档，然后更新浏览器进程中的页面状态。 |



1. 用户输入

   用户在地址栏中输入了字符，地址栏会判断这是搜索内容还是请求的url，如果是搜索内容，就会用默认的搜索引擎来合成带搜索关键字的url。如果地址栏判断内容符合url规则，如 time.geekbang.org ，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 url ：http://time.geekbang.org/

   

   当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 beforeunload 事件的机会，beforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。

   （一个典型例子就是知乎网页版，点击一个链接时，会提示是否跳转其他外部页面？这就是监听了页面的 beforeunload 事件）

   

   如果页面没有监听 beforeunload 事件或者同意了后续流程，那么标签页左边就会开始转圈圈，但是页面内容依然是之前打开的内容，只有等待提交文档阶段，页面才会被替换。

   

2. url 请求过程

   此时进入了页面资源请求过程。这时浏览器进程会通过进程间通讯 IPC 把 url 请求发送到网络进程，网络进程收到 url 请求后，会在这里发起真正的 url 请求流程，具体如下：

   

   查缓存--->如果有，直接返回

   ​	 --->如果没有--->DNS解析--->如果是https，还要建立TLS连接--->网络请求流程---

   

   --->利用ip地址和服务器建立TCP连接 --> 浏览器构建请求头等信息向服务器发送 --> 服务器接受，生成响应头数据，发给网络进程 --> 

   

3. 准备渲染过程

4. 提交文档

5. 渲染阶段