# 核心竞争力

作者：阿树
链接：https://www.zhihu.com/question/53542412/answer/2608005925
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

2013级 电子信息工程专业，5年前端经验，中间做了2年node全栈。

前端东西比较多，想拿高薪，我感觉主要3个方面。

1、基础扎实，js的一些基本原理、浏览器机制，vue react 的封装思路不求很透彻，起码得了解，知道个大概其。http机制，接口的实现思路，sql怎么写，数据库表结构 这些可以不会，但是得了解。最后就是前端工程化，脚手架那么多，不需要你手撸脚手架，但是得会用，会修改。

2、亮点，比如 webgl、大屏可视化、移动端app、跨平台的小程序、C端sass系统，这里面总得有一两个自己很熟的吧，经常做、有经验，而且积累了一些东西，设计思路、复杂情况的解决方案，通用代码等等，都可以。

3、核心竞争力。行业。核心竞争力一定是行业，举个简单的例子，做电商app，就一直做电商类产品；做工业互联网，就一直钻研工业互联网；做通讯类软件，就一直做类似产品。程序员是个很好找工作，跳槽频率也很高的工种，但是大家好学并且都有5年工作经验之后，就会发现技术上遇到瓶颈了，可以学的东西很多，但是很难大幅提升自己的竞争力。大家会的都差不多，可能各有一点特点，但是相差不大，找工作可能得靠降低薪水提升竞争力。

这个时候，行业优势就体现出来了。当职位或者薪水到达一定高度，公司招聘时目的性会非常明确，你们就想你能解决他们目前无法处理的一些行业难题。而这些难题，你不在这个行业干上几年，你连他是个啥都不知道，更别提解决了。

其次，各行业都有些特殊性，或者有些专业术语。这些都需要一个人长年累月的了解才能明白，比如我一直专注于工业互联网领域，像 BOM、物料、工艺路线、线体关系等一些行业专业术语，跨行的程序员一点都不理解，这些概念会造成比较高的行业壁垒。一个做电商的，想去制造业或者重工业公司做前端，非常难，公司会直接卡你的履历，这东西不是一个人恶补几天，背一背就能了解的。

最后，有几句肺腑之言跟大家分享： 

1、年轻可以多跳槽，涨薪快，每次跳槽别胆怯，往高了要，再慢慢降，你可能一直在低估自己的实力。

2、跳槽要有目的性，尽量有自己喜欢或者擅长的行业，不要乱跳，工作不是钱多就一定好，要符合你的职业规划，跨行业的乱跳，可能暂时工资多了点，长期看，一定是吃亏的。

3、选对行业，有些行业前景不好，就别一直坚持了，挑那种有潜力的。比如[智慧城市](https://www.zhihu.com/search?q=智慧城市&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2608005925})，起码5-8年内属于潜力行业，再往后我也不敢说；再比如 工业互联网，不是吹，再过20年也是朝阳行业，国内人工成本很高，工业智能化升级动力非常高，关键是80%以上的工业类企业智能化非常低。而且，就算做了智能化，后续也得不断升级、运维不是，这块市场非常大。

4、最后，写代码要有严谨负责的心，别偷懒，别怕麻烦。能处理的问题都处理了，不积跬步无以至千里。先这样以后再说，没事不会导致大问题，等代码多了慢慢优化... 巴拉巴拉好多类似的场景，基本就是给自己挖坑。代码能精简优化的，尽量做的优质，别怕麻烦。

------------------------------------------华丽的分割线-----------------------------------------

哇，没想到自己随手一写的回答竟然又100多赞，给前端老铁们点赞，我赶紧改一下[错别字](https://www.zhihu.com/search?q=错别字&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2608005925})(ಥ_ಥ) 

在这纠正一下哈，别频繁跳槽，太频繁了不好，特别进大厂会被卡，小公司无所谓了。进大厂之前最好保证自己在上家公司至少有2年以上的时间，要不然真的会被卡。跳槽这个东西要把握好度，合理跳槽，你的薪水可能要比同行同水平的高30%以上，太频繁，可能要找不到工作。

其次，分享一个小故事，前段时间我用G6做了个工艺路线可视化的模块，刚开始一些小组件尽量拿出来封装了，写到中期主文件代码1300+，当时没当回事，也没时间就没管。今天主文件成功堆到2000多行代码，而且这还是我重新梳理逻辑、精简代码，尽可能抽离功能(花了我接近一天时间)。说实话，我自己写的东西，而且是最近3个月写的，注释、代码结构都很清晰，我依然觉得它像坨屎山，单文件代码超过1500行，阅读效率就会大大下降，同志们引以为戒啊。当然2000多行单文件和bat这些大厂的屎山比起来都是小巫见大巫了。

----------------------------------------华丽的分割线-------------------------------------

有人问，怎么算频繁跳槽。跳槽主要分2类原因吧，一是干不下去了，这种的没办法，那就走呗！另一种就是想提升待遇，个人感觉，跳槽，35岁以下的跳槽，起码年薪总包要提升30%，要不然没多大意思，当然只是大概这样说，有些工作不光看待遇的，也看长久发展。如果大家跳槽就涨了10%的待遇，其实综合算算还不如现在，其次，也该反思自己，为什么拿不到30%以上。

其次，如果是28、9岁以下，特别是刚毕业的这种，说实话，我个人感觉跳槽频繁无所谓，1-2年换一家，这个频率完全可以接受，薪水涨的很快。换工作是累的，但是可以快速积累经验和知识，找到适合自己的行业。

最后，200人以下，不出名的小公司可以跳槽，大厂别频繁跳。人家都是记录的，窜来窜去，就不要你了。打工人通常的思路，一种毕业就去大厂，一直在大厂间选择；另一种小公司混，有实力了去大厂，然后大厂间选择。主要分人，能力强的，找到了自己的行业，而且大厂还涉及这个行业的。走第二条路，进去就是管理层。

只是我的一点个人看法，大家摸鱼的时候当个乐子看看就好。

# 前端感受

作者：随风
链接：https://zhuanlan.zhihu.com/p/539579670
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

其实普通的前端工程师是用不到去学习这么多的技术点的。就比如Node.js 。 一般的公司也不会用JavaScript语言来写后端，所以大部分的前端甚至都不需要去了解它。
我个人认为，技术框架的源码这种东西，如果能不学习，就不要去深入的学习了。很多人其实是没有达到进大厂的门槛的，大部分的前端其实都达不到，而一些中小型的公司，一般也不会去问一个技术架构的源码及核心问题（绝大部分)
其实我们前端的活总体来说都不难，就好比开车，其实绝大部分人都会开车，但是要想要把车技提升上去，那就需要去学习了，如果说你只是为了通勤，那么很多时候，你都不需要去提升你的车技。你只需要懂得怎么启动，怎么刹车等一些基本的操作就行了（实在不行就百度）。
该不该学node
大部分公司不会花费资源和时间去让前端写服务的，这是现实。造成的结果就是即便学习了，掌握了，也用不到。但是我们的webpack，工程化，做一些前端工具。都离不开node。
**前端学习3个月就可以入门，工作1年，就可以成为一个熟练的写页面的开发，工作三年，就可以选择一个前端方向进行深入钻研。**
所以，我认为应该学习，**真要这么想的话，永远都是底层搬砖那个。**
该不看该看源码
非常应该看。我看过一点点简单的源码，印象很深。确实代码写法和我们写业务区别很大的。很多API,业务中并不常用，但是源码中大量用到。这个时候就体会到ES6+提出这些概念的时候，我们当时觉得不常用，不知道是来解决什么问题的，其实只是我们无知罢了。
所以看源码有什么用呢，当然是为了**进大厂**。
一定要努力进大厂吗
【**很多人其实是没有达到进大厂的门槛的**】这句话我是同意的，但是这句话不应该成为劝退自己放弃的理由。我们深处这个行业，在国内BAT就代表了这个行业的顶端，我们一步一步向者行业顶端迈进，是绝对的正确。

#### 前端的处境

以我目前来看，前端在公司处于一个 **必要但不重要** 的地位。干好了干坏了，对公司业务影响不大。前端学习很容易学到天花板。所以需要我们`横向纵向扩展`
横向扩展:扩展边界，学习一些跨端知识，学习一些色彩搭配原理，学习一些工程化的知识。 纵向扩展:扩展深度，学习一些源码，补充计算机基础。积累沉淀一些通用知识，无论在哪些公司都能用得上的知识。
上下求索是为了干什么呢，当然是为了进大厂，所有的前端人，不是在大厂，就是在去大厂的路上。普通公司前端**一个比一个烂**，用户体验在业务面前什么都不是。大厂那些国民级别的产品，用户体验就是他们业务的一部分。

#### 前端的方向

我能想到的有这些

- 可视化
- 跨端
- 小程序
- 工程化
- DevOps
- webAssembly
- 音视频（FFmpeg）
- 全栈

#### 要不要躺平

我想了一下，如果想躺平，或者已经准备改行，想好退路，可以躺平了。大部分前端的现状，老老实实做一个能干活的前端在一个中小厂呆着，也很舒服。3年的前端和5年的前端干的活差不多，10年的前端找来干活，我嫌弃他太老。
但是除了这个前端之外，我们还能干什么。如果不能干什么，那就要我们在这个行业内卷。和别人掌握的东西一样，你需要比他深入，别人不会的东西，你得会。这些东西处理业务永远用不到，写页面，vue提供的语法那么多，常用的就那么一点。但是吧，我们还得学。
在中国这个地方，在这个行业，你不学我学，哎，卷死你们。**要么被卷死，要么卷死别人。**

#### 如何去学新知识

我们如何去学新知识呢。我想是 **重复 + 理解 + 输出**。通过博客，视频，书籍学到的东西。可以先用整理到笔记本。等过一段时间，再次看到这个知识点，再去翻出以前的笔记，对着笔记再次学习。不断重复这个过程。
等这个知识出现三次以上时，建议重新梳理笔记，自己可以试着给别人讲一遍，或者换成自己的话写一篇博客。如果别人看了你的博客能看懂，说明你写得好，掌握了这个知识点。如果你没有学会，写博客的时候，你自己会觉得晕头转向，难以下笔。
即便这样，我们做过分享，写过博客，很久不看之后，还是会忘记。学习也是需要不断坚持一个过程，曾听说某位入职 **京东** 的同学刷算法题，`leetcode刷了1000多道`，很多题都刷了不下10遍了，但是时间久了乍一看还是会忘。
但是等我们翻看博客之后，当时的记忆又会涌现出来，这个时候不是再去学习一个知识了，我们是在回忆一个知识。就像多年不骑自行车，上车就能蹬着跑，因为骑车的这种感觉已经印在我们的骨髓里了。
今天下午和领导交流，给他讲了一下npm包管理的方式，他说这个和Java的maven一样，Java这个思想已经用了十几年了。晚上翻看**JavaScript高级程序设计**，也是有了不同的感受，再去看，感觉自己当年大学的圈圈画画觉得很幼稚，没有抓住重点，当时的我并不知道什么是重点，现在看，有新的体会了。

#### 学习途径

**看书 技术博客 视频**
看书要比看博客强得多。看书会有一个全面的整体的认识，但是书上的东西没有重点。博客质量良莠不齐，语言描述参杂作者个人理解过多，很多东西描述不够准确，但是博客上的东西会突出重点，非重点，无人关注的不会出现在博客上。看博客，看书，很多时候也会因为字多，看不进去，理解困难，这时候很适合去看视频，视频的讲解很清晰，带着脑瓜子去听就好了，很少有看了视频还不懂的情况。
但是看书也好，看博客也好，看视频也好，只要不用，肯定会忘，这是正常的，符合大脑认知规律，因为工作中用的东西就那么多，学的东西大部分用不到，用到的东西肯定会，又不会去学。这就陷入了一个边学边忘，边忘边学的境地。
这反倒是一个学习知识很正常的现象。我们上学时，还少不了，课前预习，课后复习，还有家庭作业和考试，即便这样，也有人考得好，有人考得不好，很多东西也会随着时间忘记。所以这是个正常现象，不要自怨自艾。

#### 学习方式

前端的东西，很多知识点很**系统化，内容很杂，边界很宽**，加上我们学习的东西很少用到，很难做到从头到尾系统化学习一遍。所以我的建议是，放弃系统化学习的想法，从知识点学起。webpack4和5那么多知识点，从头到尾学一遍，看10min我就想放弃了。万一还没学完，出来个6咋整。
**万字解析http权威指南**和**304状态码是什么意思**的，这两篇文章放在你面前，我想大多数人都是选择先看看第2篇，然后把第一篇收藏落灰。所以学习还是得先掌握常用的，重要的知识点，等知识点多了，自然会有知识体系，再一次拿到http权威指南你就知道哪些是重点，哪些选看。

学得多了，或者掌握得多了，我想会对前端有一个全新的认识。

# 现代 JavaScript 教程

链接：https://zh.javascript.info

# 选 vue 还是 react ？

开发一个大型后台管理系统，前端选择 Vue 还是 React？ - 欲三更的回答 - 知乎 https://www.zhihu.com/question/347372270/answer/2396122181

# 前端学习方法

### 打好基础

* HTML、CSS、JS 三个件完全掌握，不懂就查MDN。
* HTML 重点掌握语义化，区分块级和内联标签，其他查文档就行。head里面的一些meta了解下。
* CSS 重点看盒子模型，定位，层级，过渡，动画和transform，知道原理和规则，还原设计稿不难。接下来重点学习几种常见的布局。然后flex、sass、less就ok了。
* JS 红宝书和《你不知道的JS》两本书搞懂即可。以下几个问题优先搞懂
  * this用法、相关原理
  * 原型、原型链
  * 闭包
  * 面向对象相关
  * 同步、异步、回调、Promise、async、await
  * 模块化 CommonJS、AMD

### 框架方面

* 新人先搞 Vue。Vue 算是比较简单的框架了，上手容易。照着官方文档来问题不大。原理方面要提高自己认识。学习怎么看源码。github常去逛逛。

* 学习框架之前，我其实特别建议，新人先去了解 Babel 和 webpack 不仅仅是使用。一些原理方面的东西工作中也会用到。[babel](https://www.zhihu.com/search?q=babel&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1543007211}) 里面会有教你如何编译代码。webpack教你如和打包文件。自己手写编译器和打包工具也不是特别难。反正对之后看vue、react源码帮助挺大。

* 搞完 Vue 全家桶，去了解下 React，React hooks 学习下新的理念。再回过头来看Vue。你会发现他们是如此的相似却又不同。

* 多去实践总结，对整体框架理解会越来越深刻。

[吃透 Vue 项目开发实践｜16个方面深入 Vue 开发体系《上》53 赞同 · 3 评论文章](https://zhuanlan.zhihu.com/p/269056226)

### 如何看源码

新人刚开始看源码，会陷入两个困境中。一是无从下手。二是看了之后感觉没啥收获。

这个也很正常。一般我们熟知的框架都有个几千甚至上万个PR。太多细节会干扰你。掌握整个节奏和流程。学习原理也比较吃力。就连找个入口都像大海捞针一样。建议从下面几个方面入手：

1. 挑简单的上手。别一开始就搞 vue、react、webpack。太难，会直接劝退新人。不要为了面试而去读。反而效果不好，面试稍微问深入一点就答不出来了。平时有兴趣多琢磨琢磨。按照难易程度，[函数库](https://www.zhihu.com/search?q=函数库&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1543007211}) < 组件库 < 框架 < [工程化](https://www.zhihu.com/search?q=工程化&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1543007211}) 分别典型代表 lodash < vant < vue < webpack
2. 手撸简易模型。像vue, webpack, babel 都有简易项目给你撸。有的创始人（[尤哥](https://www.zhihu.com/search?q=尤哥&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1543007211})）还直播手撸。国外的更多，youtube 一搜一大堆。就算不看源码，照着写出了简易 demo 对原理和理解提升都是很大的。
3. 调试开源项目。先把项目拉下来。在vscode里面跑下，核心函数多打几个断点。看看里面变量是怎么diff的。 对理解更深刻了。

看了源码是别人的，学到了是自己的。学习时候边记笔记，边思考原理，总结经验。下面来谈谈前端工程化怎么弄。

### 前端工程化

现在最流行的打包工具 webpack 用起来。当然直接用 vue-cli2、vue-cli3、create-react 都是可以的。但是 webpack 相关还是得掌握。

首先重点搞下babel、webpack。 学习下编译，打包的原理。自己配置下 webpack。尝试自己去写下下 webpack 的 loader 和 plugin。学习这些之前要懂一点 node.js， node.js 不需要全部学习。一般就日常用到读写文件fs接口，path 路径接口。这些 api 都不难写几个 demo 就懂了。基本上webpack 里面配置文件也没用到多少 node 的东西。最后自己学会配置webpack的配置文件。

如果想深入去优化打包体积和速度，就需要去了解很多webpack插件。webpack 里面最核心的就是插件了。

当然前端工程化不仅仅是这些，CI/CD可持续集成, Umi 了解下。shell各种脚本自动化命令、代码生成技术了解下。

### 性能优化

一般来说。性能优化没什么系统化的文档供人学习。完全靠一些经验和自己的实践。

我们常提到性能好坏是由什么来衡量呢？ 

访问页面地址 --> 页面首次加载数据 --> 渲染出完整页面的时长

非首次情况下，命中缓存的加载缓存数据 --> 渲染出完整页面的时长。

一般我从下面几个方面着手去做，一般问题都不大。

**减小资源（静态资源，后端加载的数据）大小**

- 压缩代码HTML/CSS/JS
- 压缩图片、音视频大小
- Tree-Sharking 消除无用代码

以上webpack都可以搞定

**避免同一时间的过多次数请求**

- CSS 实现雪碧图：使用background-position共享一张图
- 图片懒加载：监听滚动后offsetTop, 使用data-src 替换 src（真实路径）
- 列表懒加载（分批加载）：监听滚动后offsetTop， 发送请求加载下一页的数据
- 路由懒加载
- 代码分包分块加载（webpack）
- 预加载技术
- 小程序分包、预下载等。

**利用缓存（空间换时间）**

- CDN 内容分发：获取更近网络节点缓存下来的静态资源
- 浏览器缓存（自带）
- 部分资源保存在LocalStorage或者APP缓存中（手动操作）

**其他**

- SSR 服务端渲染：解决SPA框架带来JS动态渲染页面带来的延迟和白屏问题。

这些都可以去实践的，难度不大。难度大的地方可能是 dom 节点成千上万的时候渲染的性能问题。这个场景遇到的很少，方案很多。不同人有不同解决方案，有功夫可以自己去尝试尝试。

上面提到很多点都可以深入到很深。由于篇幅原因，点到即止。

### 移动端web开发

作者：邵锁
链接：https://www.zhihu.com/question/425782106/answer/1543007211
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

前端现在为什么这么火？ 各个公司都还挺缺优秀的前端。原因在于**技术红利**。

移动端web流行起来之后，特别是H5和小程序，带动了多少前端就业，前端迅速取代了安卓和iOS 的大量岗位。

回到正题：所以作为前端人，移动web一般是都要接触的。不同于PC 端。

**移动端有哪些东西呢？** 不需要全部懂，差不多知道就行了。要用的时候再去学。

1. 绝对单位换相对单位： px => rem / vw / rpx
2. 弹性布局：使用flex、grid布局
3. hairline （1px的粗线处理）：使用伪元素 + transform: scale(倍数) 缩放线框
4. WebView 环境了解下
5. 安卓iOS 兼容踩坑： 点击延迟、穿透、滚动不流畅、安全区域等等。
6. [小程序开发](https://www.zhihu.com/search?q=小程序开发&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1543007211})相关踩坑
7. JSBridge: H5 与App 通信
8. H5动画制作
9. 跨平台框架： react native、weex、flutter 等等

简单的说移动web 就是： html/css/js 跑在手机app 里面的WebView（web运行环境）。

小程序/公众号就是在这个基础上，将自己APP里面的WebView 租售给其他人使用。

微信APP ----- 提供SDK ----> 微信webview ----- 提供运行环境-----> 公众号h5 / 小程序

**为什么微信可以容纳几乎无限的H5/小程序页面呢？**

因为公众号/小程序的代码都存储在云端，通过不同的路由就可以给几乎无数的开发者使用。

使得微信成为一个运行环境+入口的存在。

### 前端会不会很吃力

作者：邵锁
链接：https://www.zhihu.com/question/425782106/answer/1543007211
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

**刚做时前端不吃力**。因为我是[软件工程专业](https://www.zhihu.com/search?q=软件工程专业&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1543007211})，学前端之前，学过 C/C++、Java、PHP、.net 成绩还不错基本都是90多分。感觉自己干后端也不吃力。实验室里面的项目都是前后都写。最爱 PHP，当时最崇拜鸟哥。本以为以后就走上PHP后端工程师的道路了，成为鸟哥那样的大神。

由于项目需要的原因，后来渐渐开始学起学 HTML、CSS、JavaScript 这些语法相关的东西。刚接触时没有感觉太大难度。

当时就想着怎么把页面搞好看，搞各种动画炫技。写一个小球从下面弹出来的效果，换各种姿势弹出。当时觉得前端真的有意思，就入了前端的坑。入坑前，以为前端就是搞各种漂亮的页面，各种特性惊艳别人。

随着接触的越来越深。接触到了 AJAX， jQuery ，Bootstrap，前端开始注重体验。各种框架横空出世 backbone => Angular => React => Vue 眼花缭乱。

折腾了 JQuery 开始折腾 [backbone](https://www.zhihu.com/search?q=backbone&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1543007211}) 觉得前端还能这样玩。有些迷茫了，感觉脑袋快要炸了，那段时间特别焦虑，疯狂看书写代码，怎么这么多东西要学啊。 

JavaScript 也不精通，到原型就不理解了，虽然有C++,JAVA面向对象的知识，但JavaScript 你怎么和别人玩的不是一个套路啊。 当时就都用ES6了， 行，学。都用Sass了，行，学。 不学也可以，看不懂别人的代码呀。

**毕业前为准备校招前端工程师，真的很吃力**。就怕校招面试时，自己啥都不懂。

功夫不负有心人，校招时候顺利拿到了自己满意的Offer。记得当时和面试官对答入流，好像找到知音一样。面试官也是过来人，基本能问的都问了。

拿到Offer之后就去了实习。实习第一个任务：将一个ES6的后台管理系统重构成 Vue2.0 全家桶的项目。有个导师带，但是她和我是不同项目，出了架构以外代码都是自己写。

这个阶段还是收获了很多：

1. git 命令特别熟练。commit、stash、merge/rebase、cherry-pick、push/pull/fetch、[reset](https://www.zhihu.com/search?q=reset&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1543007211})等等基本都敲都特别多了
2. 严格了代码规范。Eslint、prettier 都用起来了
3. 会自己写业务组件，会封装高级组件、写常规页面了。基本上大部分不是特别复杂的交互都ok。难一点多找下资料可以做出来。
4. 学会管理API了。自己尝试封装了 axios。统一处理错误和弹窗。
5. 会抽取公共css、JavaScript 函数，编写CSS 变量和JavaScript 常量了
6. webpack 能看懂配置文件了。

实习过后顺利转正。转正之后，换了另外一个导师带，加入到项目组作为一个比较大的项目的核心开发。基本不再做管理系统了。主要做一个saas 平台。涉及比较难的富文本编辑，UI 拖拽生产文章，数据可视化生产报表等等。还写了几个谷歌浏览器插件。

1. 开始提升写页面效率，写的比较快了。
2. 研究 webpack 的插件打包编译效率
3. 研究 babel 编译原理
4. 研究了 Vue 编译的一些原理
5. 研究了 一些图表的使用，多半使用的[echart](https://www.zhihu.com/search?q=echart&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1543007211})。常规图表基本都用过。
6. CI & CD 自己去搭建。学了一些 shell 脚本开发。 研究了 docker 相关的东西。
7. 尝试去写基础组件，搭建基础组件库。
8. 学习 React 相关的语法。
9. 研究富文本编辑，图片压缩裁剪原理等等
10. 写一个简单的微信公众号，接触到了 H5 开发。

工作第一年，基本上主战场在PC 端。**前半年挺吃力，后半年熟练后游刃有余。**会怼产品，会喷设计，会和后端兄弟配合默契。和团队感情也很深了。

无奈项目由于某些原因终止，团队解散，调到新团队。在老东家工作一年多后，由于个人原因离开去了一家新的的公司，主战场从PC 到了手机。开始接触移动H5、[hybrid](https://www.zhihu.com/search?q=hybrid&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1543007211}) 开发。

### 学习吃力的原因肯定是方法不太正确，真正学到东西

1. 详略得当：前端知识太多，抓重点学，不要像背字典一样。
2. 不要急着写代码，先理清流程（以一个函数为单位，可以先写注释）再写代码。
3. 看视频看讲解是会误以为自己会了，其实并没有。
4. 学会总结：一句话可以讲清楚的事情，不要多说一句。减少心智负担。
5. 不介意复制代码，但是要知道这个代码里面大致实现原理。感兴趣自己重写一个。
6. 较大的项目，不要急着看代码。可以先把项目跑起来。通过改代码里面的参数来理解里面的核[心流](https://www.zhihu.com/search?q=心流&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1543007211})程。
7. demo 式编程。 对于新框架，参考demo来上手更快更容易理解。
8. 渐进式编程。对于比较复杂的功能/需求。不要想着一气呵成。先实现一个核心，每次往上面加细节，有点像绘画。
9. 断点单步调试很有用，定位bug会更快。当然有些不易调试的应用选择打log。一次打 log 要多打点，免得打完log,有得再加。
10. 黑盒太多的项目，实在找不到bug原因。发给同事帮忙看。可能很快就能看出来。当局者迷，旁观者清。(很多时候是拼写的问题)

作者：邵锁
链接：https://www.zhihu.com/question/425782106/answer/1543007211
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# 优雅的 JS 单行代码

地址：https://mp.weixin.qq.com/s/yET5aiFwbxUZIeiOwNmt5A

# 提升前端开发质量的十点经验沉淀

地址：https://juejin.cn/post/7139690286527021064

## 1、记得错误处理

特别是网络请求或者其他异步操作中，`await` 记得包裹 `try catch`，可以给用户一个友好提示，同时可以考虑 `catch` 中需要做什么兜底处理，必要时进行上传日志。

```js
try {
  this.loading = this.$loading({
    lock: true,
    text: '加载中...',
    spinner: 'el-icon-loading',
    background: 'rgba(0, 0, 0, 0.7)',
  });
  const info = await resDistributeService({ taskTicketId: this.id });
  ...
} catch (e) {
  this.$message({
    type: 'error',
    message: e.msg || e.message || '失败',
  });
} finally {
  this.loading.close();
}
```

可以结合 `finally`，处理 `loading` 等。

## 2、数字 0 的校验

前端经常使用 `!v` ，来判断 `v` 是不是有值。

```js
if(!v){
  return
}
doSomething()
复制代码
```

但如果 `0` 是 `v` 的有效值 ，此时本该处理，但会提前结束，最终引发错误。此时需要显示的判断是否是 `null` 或者 `undefined` 。

```js
if(v === null || v=== undefined){
  return
}
doSomething()
```

## 3、默认对象采用函数返回

由于 `js` 中的对象是引用，因此赋默认值的时候最好通过函数，每次都返回一个新对象。

bad:

```javascript
const defaultCondition = {
  name: '',
  conditionList: [
    {
      conditionCode: '',
      conditionValue: null,
    },
  ],
}
export default {
    data() {
        return {
            condition: {...defaultCondition},
        };
    },
    methods: {
        closeDialog() {
            this.condition =  {...defaultCondition};
            this.configId = null;
            this.$refs.form.resetFields();
        },
    },
};
复制代码
```

good:

```javascript
const getDefaultCondition = () => ({
  name: '',
  conditionList: [
    {
      conditionCode: '',
      conditionValue: null,
    },
  ],
})
export default {
    data() {
        return {
            condition: getDefaultCondition(),
        };
    },
    methods: {
        closeDialog() {
            this.condition = getDefaultCondition();
            this.configId = null;
            this.$refs.form.resetFields();
        },
    },
};
复制代码
```

## 4、接口地址单独存放

将接口的定义放到统一文件中，未来变动改动起来会比较方便，如果各个 `url` 都写死在页面中以后就很麻烦了。

```javascript
// service.js
import request from 'utils/request';

const service = new (request('/api/m/mallorder/exp/compensation/customer'))();

export const listService = (params) => {
    return service.post('/queryRuleList', params);
};

export const listDataKey = 'ruleVOList';
export const idKey = 'ruleId';

export const dialogEnumService = () => {
    return service.get('/info');
};

export const saveService = (params) => {
    return service.post('/saveRule', params);
};

export const detailService = (params) => {
    return service.get('/detail', params);
};
复制代码
```

此外，网络请求一般都会在 `npm` 包的基础上自己再包一层，一方面可以注入共用参数，另一方面可以对返回数据进行统一的错误处理。

## 5、函数多参数采用对象

如果定义一个函数需要 3 个以上的参数

```javascript
function(a,b,c,d){

}
复制代码
```

此时可以考虑采用对象解构，改为

```javascript
function({a=1,b,c,d}={}){

}
复制代码
```

好处是未来需要扩展参数的时候，不需要太担心其他地方调用时候传参是否会引起问题。

当然，如果参数过多也需要思考一下当前函数是否承载了太多的功能，进行一下功能上的拆分。

## 6、函数单一职责

当我们已经定义了一个函数，比如去初始一些变量。

```javascript
function initOptions(){
  a = xxx
  b = xxx
}
复制代码
```

此时我们需要做另一件无关的事 【A】，虽然它和 `initOptions` 调用的时机一致，但最好不要直接放到 `initOptions` 中，而是新建一个函数单独调用。

不然未来如果其他地方也要调 `initOptions`，但此时可能并不需要做【A】这件事情就会引起 `bug`。

## 7、参数合法性判断

由于 `js` 语言的灵活性，函数传入的参数很可能不符合预期，必要时我们需要进行判断并且进行兜底处理，不可完全信任调用方。

团队合作中，该函数在未来极大可能会被其他人调用。

```javascript
function doSomeThing(params1, params2) {
  if(params1 === null){
    return;
  }
  if(params2){
    ...
  }
  // 再去做我们的事情
}
复制代码
```

如果后边的流程强依赖于 `params`，我们可以直接 `return`，必要时也可以上报日志或者 `throw Error`。

## 8、整数的处理

`js` 中没有整数类型，即 `java` 中的 `int`、`long` 这些，所有数字都遵循 `IEEE 754` 标准，即 `java` 中的 `double` 类型，详细的可参考 [浮点数详解。](https://link.juejin.cn/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F75581822)

可以精确表示的最大整数是 `9007199254740991`，共 `16` 位，超过这个数精度可能会丢失，对于新接口，可以问一下后端相应数字字段的最大值会是多少。

对于浮点数的处理，除了众所周知的 `0.1 + 0.2 === 0.3` 的值为` false` 外，当我们对数字进行运算的时候也需要注意。

常见的将 `9.04` 元转为 `904` 分：

9.04 * 100 > 903.9999999999

我们需要对结果进行取整：

Number((9.04 * 100).toFixed())   >  904

## 9、可选链

可选链操作符，参考 [MDN](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FOptional_chaining) ，用的比较多。

和后端定的数组或者对象，后端有时候返回来的很可能是 `null` 甚至没有该字段，因此前端可以用可选链操作符用于数组、对象、函数，防止出现错误直接阻断后续流程。

```javascript
let nestedProp = obj.first?.second; // 等效于 obj.first && obj.fisrt.second
//后续流程
复制代码
```

但不要过度使用可选链，如果某些地方理论上不会出问题，比如 `let test = obj.first?.second`，如果 `second`一定能取到，我们直接 `let test = obj.first.second` 即可。

不然未来如果这里由于某种原因出了问题导致 `obj.first` 是 `null`，但我们使用了可选链，所以 `obj.first?.second` 也不会报错，我们就永远不会知道这里出现问题了。

当然也需要权衡下，不加可选链造成` js Error` 会不会影响业务逻辑。

## 10、对象或数组引用

修改或者使用对象、数组时，时刻切记它们为引用，一处修改会造成处处修改。

 `Vue` 一些常见的点也总结了一下，在语雀建了一个文档，未来有其他想法也会再更新一下，感兴趣的同学可以收藏一下，[前端实践沉淀](https://link.juejin.cn/?target=https%3A%2F%2Fwww.yuque.com%2Fbooks%2Fshare%2F4946f854-2cac-4918-b70f-223fb173b7c2)。

# 20个工具函数助力前端快速开发

地址：https://mp.weixin.qq.com/s/8Dn8M2r3mafCWt48ws5_CA

地址：https://juejin.cn/post/7132714583399071758

## 1、校验数据类型

```js
export const typeOf = function(obj) {
  return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase()
}
```

示例：

```js
typeOf('树哥')  // string
typeOf([])  // array
typeOf(new Date())  // date
typeOf(null) // null
typeOf(true) // boolean
typeOf(() => { }) // function
```

## 2、防抖

```js
export const debounce = (() => {
  let timer = null
  return (callback, wait = 800) => {
    timer&&clearTimeout(timer)
    timer = setTimeout(callback, wait)
  }
})()
```

示例：

vue 中使用

```js
methods: {
  loadList() {
    debounce(() => {
      console.log('加载数据')
    }, 500)
  }
}
```

## 3、节流

```js
export const throttle = (() => {
  let last = 0
  return (callback, wait = 800) => {
    let now = +new Date()
    if (now - last > wait) {
      callback()
      last = now
    }
  }
})()
```

## 4、手机号脱敏

```js
export const hideMobile = (mobile) => {
  return mobile.replace(/^(\d{3})\d{4}(\d{4})$/, "$1****$2")
}
```

## 5、开启全屏

```js
export const launchFullscreen = (element) => {
  if (element.requestFullscreen) {
    element.requestFullscreen()
  } else if (element.mozRequestFullScreen) {
    element.mozRequestFullScreen()
  } else if (element.msRequestFullscreen) {
    element.msRequestFullscreen()
  } else if (element.webkitRequestFullscreen) {
    element.webkitRequestFullScreen()
  }
}
```

## 6、关闭全屏

```js
export const exitFullscreen = () => {
  if (document.exitFullscreen) {
    document.exitFullscreen()
  } else if (document.msExitFullscreen) {
    document.msExitFullscreen()
  } else if (document.mozCancelFullScreen) {
    document.mozCancelFullScreen()
  } else if (document.webkitExitFullscreen) {
    document.webkitExitFullscreen()
  }
}
```

## 7、大小写转换

```js
// str 待转换的字符串
// type 1-全大写 2-全小写 3-首字母大写

export const turnCase = (str, type) => {
  switch (type) {
    case 1:
      return str.toUpperCase()
    case 2:
      return str.toLowerCase()
    case 3:
      //return str[0].toUpperCase() + str.substr(1).toLowerCase() // substr 已不推荐使用
      return str[0].toUpperCase() + str.substring(1).toLowerCase()
    default:
      return str
  }
}
```

示例：

```js
turnCase('vue', 1) // VUE
turnCase('REACT', 2) // react
turnCase('vue', 3) // Vue
```

## 8、解析 URL 参数

```js
export const getSearchParams = () => {
  const searchPar = new URLSearchParams(window.location.search)
  const paramsObj = {}
  for (const [key, value] of searchPar.entries()) {
    paramsObj[key] = value
  }
  return paramsObj
}
```

示例：

```js
// 假设目前位于 https://****com/index?id=154513&age=18;
getSearchParams(); // {id: "154513", age: "18"}
```

## 9、判断手机是 安卓 还是 ios

```js
/** 
 * 1: ios
 * 2: android
 * 3: 其它
 */
export const getOSType=() => {
  let u = navigator.userAgent, app = navigator.appVersion;
  let isAndroid = u.indexOf('Android') > -1 || u.indexOf('Linux') > -1;
  let isIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
  if (isIOS) {
    return 1;
  }
  if (isAndroid) {
    return 2;
  }
  return 3;
}
```

## 10、数组对象根据字段去重

```js
// arr 要去重的数组
// key 根据去重的字段名

export const uniqueArrayObject = (arr = [], key = 'id') => {
  if (arr.length === 0) return
  let list = []
  const map = {}
  arr.forEach((item) => {
    if (!map[item[key]]) {
      map[item[key]] = item
    }
  })
  list = Object.values(map)

  return list
}
```

示例：

```js
const responseList = [
    { id: 1, name: '树哥' },
    { id: 2, name: '黄老爷' },
    { id: 3, name: '张麻子' },
    { id: 1, name: '黄老爷' },
    { id: 2, name: '张麻子' },
    { id: 3, name: '树哥' },
    { id: 1, name: '树哥' },
    { id: 2, name: '黄老爷' },
    { id: 3, name: '张麻子' },
]

uniqueArrayObject(responseList, 'id')
// [{ id: 1, name: '树哥' },{ id: 2, name: '黄老爷' },{ id: 3, name: '张麻子' }]
```

## 11、滚动到页面顶部

```js
export const scrollToTop = () => {
  const height = document.documentElement.scrollTop || document.body.scrollTop;
  if (height > 0) {
    window.requestAnimationFrame(scrollToTop);
    window.scrollTo(0, height - height / 8);
  }
}
```

## 12、滚动到元素位置

```js
export const smoothScroll = element =>{
    document.querySelector(element).scrollIntoView({
        behavior: 'smooth'
    });
};
```

示例：

```js
smoothScroll('#target'); // 平滑滚动到 ID 为 target 的元素
```

## 13、uuid

```js
export const uuid = () => {
  const temp_url = URL.createObjectURL(new Blob())
  const uuid = temp_url.toString()
  URL.revokeObjectURL(temp_url) //释放这个url
  return uuid.substring(uuid.lastIndexOf('/') + 1)
}
```

示例：

```js
uuid() // a640be34-689f-4b98-be77-e3972f9bffdd
```

不过要吐槽一句的是，uuid一般应由后端来进行生成

## 14、金额格式化

```js
// {number} number：要格式化的数字
// {number} decimals：保留几位小数
// {string} dec_point：小数点符号
// {string} thousands_sep：千分位符号

export const moneyFormat = (number, decimals, dec_point, thousands_sep) => {
  number = (number + '').replace(/[^0-9+-Ee.]/g, '')
  const n = !isFinite(+number) ? 0 : +number
  const prec = !isFinite(+decimals) ? 2 : Math.abs(decimals)
  const sep = typeof thousands_sep === 'undefined' ? ',' : thousands_sep
  const dec = typeof dec_point === 'undefined' ? '.' : dec_point
  let s = ''
  const toFixedFix = function(n, prec) {
    const k = Math.pow(10, prec)
    return '' + Math.ceil(n * k) / k
  }
  s = (prec ? toFixedFix(n, prec) : '' + Math.round(n)).split('.')
  const re = /(-?\d+)(\d{3})/
  while (re.test(s[0])) {
    s[0] = s[0].replace(re, '$1' + sep + '$2')
  }

  if ((s[1] || '').length < prec) {
    s[1] = s[1] || ''
    s[1] += new Array(prec - s[1].length + 1).join('0')
  }
  return s.join(dec)
}
```

示例：

```js
moneyFormat(10000000) // 10,000,000.00
moneyFormat(10000000, 3, '.', '-') // 10-000-000.000
```

## 15、存储操作

```js
class MyCache {
  constructor(isLocal = true) {
    this.storage = isLocal ? localStorage : sessionStorage
  }

  setItem(key, value) {
    if (typeof (value) === 'object') value = JSON.stringify(value)
    this.storage.setItem(key, value)
  }

  getItem(key) {
    try {
      return JSON.parse(this.storage.getItem(key))
    } catch (err) {
      return this.storage.getItem(key)
    }
  }

  removeItem(key) {
    this.storage.removeItem(key)
  }

  clear() {
    this.storage.clear()
  }

  key(index) {
    return this.storage.key(index)
  }

  length() {
    return this.storage.length
  }
}

const localCache = new MyCache()
const sessionCache = new MyCache(false)

export { localCache, sessionCache }
```

示例：

```js
localCache.getItem('user')
sessionCache.setItem('name','树哥')
sessionCache.getItem('token')
localCache.clear()
```

## 16、下载文件

```js
// api 接口
// params 请求参数
// fileName 文件名


const downloadFile = (api, params, fileName, type = 'get') => {
  axios({
    method: type,
    url: api,
    responseType: 'blob', 
    params: params
  }).then((res) => {
    let str = res.headers['content-disposition']
    if (!res || !str) {
      return
    }
    let suffix = ''
    // 截取文件名和文件类型
    if (str.lastIndexOf('.')) {
      fileName ? '' : fileName = decodeURI(str.substring(str.indexOf('=') + 1, str.lastIndexOf('.')))
      suffix = str.substring(str.lastIndexOf('.'), str.length)
    }
    //  如果支持微软的文件下载方式(ie10+浏览器)
    if (window.navigator.msSaveBlob) {
      try {
        const blobObject = new Blob([res.data]);
        window.navigator.msSaveBlob(blobObject, fileName + suffix);
      } catch (e) {
        console.log(e);
      }
    } else {
      //  其他浏览器
      let url = window.URL.createObjectURL(res.data)
      let link = document.createElement('a')
      link.style.display = 'none'
      link.href = url
      link.setAttribute('download', fileName + suffix)
      document.body.appendChild(link)
      link.click()
      document.body.removeChild(link)
      window.URL.revokeObjectURL(link.href);
    }
  }).catch((err) => {
    console.log(err.message);
  })
}
```

使用：

```js
downloadFile('/api/download', {id}, '文件名')
```

## 17、时间操作

关于时间操作，没必要自己再写一大串代码了，强烈推荐使用 **day.js**

Day.js 是一个仅 2kb 大小的轻量级 JavaScript 时间日期处理库，下载、解析和执行的JavaScript更少，为代码留下更多的时间。

## 18、深拷贝

```js
export const clone = parent => {
  // 判断类型
  const isType = (obj, type) => {
    if (typeof obj !== "object") return false;
    const typeString = Object.prototype.toString.call(obj);
    let flag;
    switch (type) {
      case "Array":
        flag = typeString === "[object Array]";
        break;
      case "Date":
        flag = typeString === "[object Date]";
        break;
      case "RegExp":
        flag = typeString === "[object RegExp]";
        break;
      default:
        flag = false;
    }
    return flag;
  };

  // 处理正则
  const getRegExp = re => {
    var flags = "";
    if (re.global) flags += "g";
    if (re.ignoreCase) flags += "i";
    if (re.multiline) flags += "m";
    return flags;
  };
  // 维护两个储存循环引用的数组
  const parents = [];
  const children = [];

  const _clone = parent => {
    if (parent === null) return null;
    if (typeof parent !== "object") return parent;

    let child, proto;

    if (isType(parent, "Array")) {
      // 对数组做特殊处理
      child = [];
    } else if (isType(parent, "RegExp")) {
      // 对正则对象做特殊处理
      child = new RegExp(parent.source, getRegExp(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (isType(parent, "Date")) {
      // 对Date对象做特殊处理
      child = new Date(parent.getTime());
    } else {
      // 处理对象原型
      proto = Object.getPrototypeOf(parent);
      // 利用Object.create切断原型链
      child = Object.create(proto);
    }

    // 处理循环引用
    const index = parents.indexOf(parent);

    if (index != -1) {
      // 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象
      return children[index];
    }
    parents.push(parent);
    children.push(child);

    for (let i in parent) {
      // 递归
      child[i] = _clone(parent[i]);
    }

    return child;
  };
  return _clone(parent);
};
```

此方法存在一定局限性：一些特殊情况没有处理: 例如Buffer对象、Promise、Set、Map。

**如果确实想要完备的深拷贝，推荐使用 lodash 中的 cloneDeep 方法。**

## 19、模糊搜索

```js
// list 原数组
// keyWord 查询的关键词
// attribute 数组需要检索属性

export const fuzzyQuery = (list, keyWord, attribute = 'name') => {
  const reg = new RegExp(keyWord)
  const arr = []
  for (let i = 0; i < list.length; i++) {
    if (reg.test(list[i][attribute])) {
      arr.push(list[i])
    }
  }
  return arr
}
```

示例：

```js
const list = [
  { id: 1, name: '树哥' },
  { id: 2, name: '黄老爷' },
  { id: 3, name: '张麻子' },
  { id: 4, name: '汤师爷' },
  { id: 5, name: '胡万' },
  { id: 6, name: '花姐' },
  { id: 7, name: '小梅' }
]
fuzzyQuery(list, '树', 'name') // [{id: 1, name: '树哥'}]
```

## 20、遍历树节点

```js
export const foreachTree = (data, callback, childrenName = 'children') => {
  for (let i = 0; i < data.length; i++) {
    callback(data[i])
    if (data[i][childrenName] && data[i][childrenName].length > 0) {
      foreachTree(data[i][childrenName], callback, childrenName)
    }
  }
}
```

示例：假设我们要从树状结构数据中查找 id 为 9 的节点

```js
const treeData = [{
  id: 1,
  label: '一级 1',
  children: [{
    id: 4,
    label: '二级 1-1',
    children: [{
      id: 9,
      label: '三级 1-1-1'
    }, {
      id: 10,
      label: '三级 1-1-2'
    }]
  }]
 }, {
  id: 2,
  label: '一级 2',
  children: [{
    id: 5,
    label: '二级 2-1'
  }, {
    id: 6,
    label: '二级 2-2'
  }]
  }, {
    id: 3,
    label: '一级 3',
    children: [{
      id: 7,
      label: '二级 3-1'
    }, {
      id: 8,
      label: '二级 3-2'
    }]
}],

let result
foreachTree(data, (item) => {
  if (item.id === 9) {
    result = item
  }
})
console.log('result', result)  // {id: 9,label: "三级 1-1-1"}   
```

# ts文章

https://juejin.cn/post/7124117404187099172#heading-22

# vue项目开发我遇到的问题

https://juejin.cn/post/7119018849353072677

# 组件二次封装我们在封装什么

https://juejin.cn/post/7127925414885851144

# 首屏优化

https://juejin.cn/post/7117515006714839047
