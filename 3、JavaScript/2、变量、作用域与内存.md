## 原始值和引用值

* JS变量可以包含两种不同类型的数据：原始值（基本数据类型）和引用值（对象），原始值则是保存在栈内存中的，而引用值是保存在堆内存中的。JS不允许直接访问内存位置，也就不能直接操作对象所在的内存空间。我们在操作对象时，实际上操作的是该对象的引用而非实际的对象本身。

* 对于引用值，我们可以随时添加，修改，删除其属性和方法。原始值没有属性。

* 原始类型的初始化值可以只用字面量形式，也可以使用`new`关键字形式，区别为使用`new`关键字的话，会创建一个Object实例，其行为类似原始值。

* 除了存储方式的不同，还有变量复制时的不同：原始值赋值给另一个变量后，两个变量独立使用，且不互相干扰，其实和其存储在栈内存有关。而引用值从一个变量赋值给另一个变量时，其实是把其引用（内存地址）赋值过去，这时，两个变量都指向了同一个内存地址，如果修改其中一个，则另一个会发生变化。

* 传递参数的不同：JS中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中。

  ```js
  function addTen(num) {
    num = num + 10
    return num
  }
  let count = 20
  let result = addTen(count)
  console.log(count) // 20
  console.log(result) // 30
  
  /*
  	分析：addTen()函数有一个参数num，它其实是一个局部变量，变量count作为参数传入，count的值为20，这个值被复制到参数num以便在addTen()函数使用。在函数内部，参数num的值被加上了10，但这并不会影响函数外部的原始变量count。参数num和count互不干扰。
  */
  ```

  ```js
  function setName(obj) {
    obj.name = 'ryan'
  }
  let person = new Object()
  setName(person)
  console.log(person.name) // 'ryan'
  
  /*
  	分析：person和obj都指向了同一个对象。即使对象是按值传进函数的，obj也会通过引用访问对象。当函数内部给obj设置了name属性时，函数外部的对象也会反映这个变化。因为obj指向的对象保存在全局作用域的堆内存上。
  */
  ```

  ```js
  function setName(obj) {
    obj.name = 'ryan'
    obj = new Object() // <<<
    obj.name = 'bike' // <<<
  }
  let person = new Object()
  setName(person)
  console.log(person.name) // 'ryan'
  
  /*
  	如果person是按照引用传递的，那么person应该自动将指针改为指向name为'bike'的对象，但是当我们再次访问person.name时，他的值还是'ryan'。这表明函数中参数的值发生改变之后，原始的引用仍然没变。当obj在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。
  */
  ```

* `typeof`关键字对原始值的判断非常有用，比如：字符串、数值、布尔值、undefined。但是它对引用值的作用并不大，我们通常不关心一个值是不是一个对象，而是想知道它是什么类型的对象，为此，引入了`instanceof`操作符

  ```js
  console.log(person instanceof Object) // 变量person是Object吗
  console.log(colors instanceof Array) // 变量colors是Array吗
  console.log(pattern instanceof RegExp) // 变量pattern是RegExp吗
  ```

  如果变量是给定引用类型，则`instanceof`操作符返回true。按照定义，所有引用值都是Object的实例，因此通过`instanceof`操作符检测任何引用值和Object构造函数都会返回true。类似，用其检测所有的原始值，都会返回false，因为原始值不是对象。







## 浏览器工作原理

-> 我们输入网址 

-> dns解析 

-> ip地址 

-> 浏览器返回给我们`index.html` 

-> 浏览器在解析`index.html`过程中

-> 遇到`link`标签就会下载对应的`xxx.css`

-> 遇到`script`标签就会下载我们的`xxx.js`文件







## 浏览器内核

* 也叫排版引擎、浏览器引擎、页面渲染引擎

* 浏览器内核分为两个部分：
  * webCore（WebView）：负责HTML解析，布局，渲染相关工作
  * JavaScriptCore：解析，执行JS代码








## 浏览器渲染过程

* 浏览器内核使用`HTML Parser`来对我们的`HTML`进行渲染，生成`DOM tree`；与此同时，`css Parser`会对我们的样式进行处理，生成`Style Rules`然后`DOM tree + Style Rules = Render tree`两者结合就会生成一个渲染树（这里根据不同的环境还要重新布局layout），然后我们根据最终的`render tree`来进行绘制，最终页面展示出来。
* 注意：我们在生成`DOM tree`的时候有很重要的一步就是`JS`对我们`DOM`的操作，浏览器是需要对我们的`JS`代码进行执行的。谁来帮助我们来执行`JS`代码呢？这就引出了我们的`JS`引擎









## JS引擎——V8

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2928490/1647704241533-c9e74dba-beb3-4c5d-a3f3-9160fe814831.png?x-oss-process=image%2Fresize%2Cw_1500%2Climit_0)

* 高级语言都是需要转化为机器语言（010101101010111001），才能被CPU所执行，JS引擎就是用来干这事的。
* parse的过程分为词法分析和语法分析，最终将代码转为抽象语法树AST（有一个[网站](https://astexplorer.net)可以看到当前代码转为AST之后的样子）
* 为什么要转成AST呢？因为AST是一个树结构，它里面的关键字都是比较固定，我们可以很方便的对AST进行一些修改之类的操作。比如：babel将TS代码->AST->修改AST->生成JS代码；Vue里面将template->AST->createVNode将模板语法转为一行行JS代码。
* 为什么把AST转为字节码而不是机器码？因为当前的JS代码跑在什么环境上是不一定的，而不同的cpu对应的机器码指令集是不一致的，但是字节码是跨平台的，所以才转为字节码，字节码最后->汇编指令->机器码->执行。在转为AST树的过程中，会经过Parser和PreParser。Parser就是直接将tokens转成AST树架构。
* 但是为什么需要预解析PreParser呢？因为并不是所有的JS代码在一开始就会被执行，如果对所有的JS代码进行解析，必然就会影响性能，所以V8引擎就实现了延迟解析的方案，将不必要的函数进行预解析，也就是只解析暂时需要的内容，而对函数的全量解析是在函数被调用的时候才会进行，比如我们在一个函数outer中定义了另一个函数inner，inner函数就会进行预解析PreParser，进而引出了我们的作用域的概念。






## 执行上下文与作用域
* 执行上下文在js中是比较重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（VO），这个上下文中定义的所有变量和函数都存在于这个VO上。代码无法访问该VO，但是后台处理数据时会用到。
* 全局上下文是最外层的上下文。根据ES实现的宿主环境不同，表示全局上下文的对象可能不同，浏览器中，全局上下文就是window对象，`var`定义的全局变量和函数都会成为`window`对象的属性和方法。`let const`定义的顶级声明不会定义在全局上下文中，但作用域链解析时效果相同。上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才被销毁，关闭网页或退出浏览器）。
* 代码解析时：在代码被Parse解析为AST的过程中（注意此时代码没有执行），V8引擎会首先创建一个对象叫做`GlobalObject`
* 代码运行时：V8引擎为了执行代码，内部会存在一个执行上下文栈`Execution Context Stack`（也叫函数调用栈），以后只要是代码想执行，都要放在这个执行上下文栈中来执行。
  * Case1（全局代码执行过程）：一般情况下，执行上下文栈中放的都是函数，但是如果我们在全局声明了变量，为了全局代码能够执行，需要创建一个全局执行上下文（Global Excution  Context，注意，只有全局代码被执行的时候才会创建全局执行上下文），然后，把这个全局执行上下文GEC放入我们的执行上下文栈ECS中进行执行，全局执行上下文GEC中存在一个VO（variable object）对象，这个VO对象其实就是我们解析代码时生成的GO对象，然后才是真正开始执行代码   >>>   一行一行执行，如果有变量的重新赋值，就会通过VO找到GO，然后改掉GO中对应变量的值，这也就是为什么我们在变量未赋值之前打印结果是undefined的原因，这就叫作用域提升！
  * Case2 （函数执行过程）
  * Case3 （函数嵌套执行过程）
  * Case4 （函数调用执行过程）









## 内存管理及垃圾回收

* 不论什么编程语言，在代码的执行过程中都是需要给它分配内存的。不同的是某些编程语言需要我们自己手动管理内存，某些编程语言会可以自动帮我们管理内存
* 硬盘、内存、cpu
* 代码先从硬盘加载到内存中，再由cpu执行代码，在代码执行过程中，会继续从内存中开辟空间来存放变量。
* 内存的管理都是有如下的生命周期的
  * 第一步：分配申请你需要的内存（申请）
  * 第二步：使用分配的内存（存放一些东西，比如对象等，使用）
  * 第三步：不需要使用时，对其进行释放（释放）
* C/C++/Object C 语言需要手动管理内存（malloc和free函数）；Java/JavaScript/Swift/等自动管理内存
* JS在定义变量时为我们自动分配内存，但是对于不同的数据类型分配方式是不一样的
  * 对于基本数据类型：直接在栈空间进行分配
  * 对于复杂数据类型：在堆空间中分配一块空间来存放数据，然后将这一块的内存地址（如0xa00）作为引用（C语言中叫做指针）保存在栈内存中，故而叫做引用类型
* JS的引擎有自己的垃圾回收器（Garbage Collection，GC），但是，GC怎么知道哪些对象是不再使用的呢？这就用到GC算法了
  * 算法一：引用计数（堆内存中的每一个对象都有一个属性叫做retain count，默认为0，当别的地方引用一次该对象，该数字就加一，当对象的这个属性值为0时，垃圾回收器就知道可能没有地方使用它了，这时就会回收改空间。存在一个很大的弊端：循环引用，比如两个对象互相引用对方，如果不=null，这两个对象就会一直在内存中了，造成内存泄漏）
  * 算法二：标记清除（堆内存中有一个根对象，是一个树结构，如果从根对象出发一直找，应该就会找到所有被使用的对象，如果有的对象没有被包含在树中，就说该对象是不可达的，就会销毁掉，这时，即使两个对象互相引用，但是是不可达的，也会销毁掉，很好的解决了循环引用问题）