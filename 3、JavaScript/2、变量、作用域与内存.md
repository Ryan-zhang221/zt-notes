## 原始值和引用值

* JS变量可以包含两种不同类型的数据：原始值（基本数据类型）和引用值（对象），原始值则是保存在栈内存中的，而引用值是保存在堆内存中的。JS不允许直接访问内存位置，也就不能直接操作对象所在的内存空间。我们在操作对象时，实际上操作的是该对象的引用而非实际的对象本身。

* 对于引用值，我们可以随时添加，修改，删除其属性和方法。原始值没有属性。

* 原始类型的初始化值可以只用字面量形式，也可以使用`new`关键字形式，区别为使用`new`关键字的话，会创建一个Object实例，其行为类似原始值。

* 除了存储方式的不同，还有变量复制时的不同：原始值赋值给另一个变量后，两个变量独立使用，且不互相干扰，其实和其存储在栈内存有关。而引用值从一个变量赋值给另一个变量时，其实是把其引用（内存地址）赋值过去，这时，两个变量都指向了同一个内存地址，如果修改其中一个，则另一个会发生变化。

* 传递参数的不同：JS中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中。

  ```js
  function addTen(num) {
    num = num + 10
    return num
  }
  let count = 20
  let result = addTen(count)
  console.log(count) // 20
  console.log(result) // 30
  
  /*
  	分析：addTen()函数有一个参数num，它其实是一个局部变量，变量count作为参数传入，count的值为20，这个值被复制到参数num以便在addTen()函数使用。在函数内部，参数num的值被加上了10，但这并不会影响函数外部的原始变量count。参数num和count互不干扰。
  */
  ```

  ```js
  function setName(obj) {
    obj.name = 'ryan'
  }
  let person = new Object()
  setName(person)
  console.log(person.name) // 'ryan'
  
  /*
  	分析：person和obj都指向了同一个对象。即使对象是按值传进函数的，obj也会通过引用访问对象。当函数内部给obj设置了name属性时，函数外部的对象也会反映这个变化。因为obj指向的对象保存在全局作用域的堆内存上。
  */
  ```

  ```js
  function setName(obj) {
    obj.name = 'ryan'
    obj = new Object() // <<<
    obj.name = 'bike' // <<<
  }
  let person = new Object()
  setName(person)
  console.log(person.name) // 'ryan'
  
  /*
  	如果person是按照引用传递的，那么person应该自动将指针改为指向name为'bike'的对象，但是当我们再次访问person.name时，他的值还是'ryan'。这表明函数中参数的值发生改变之后，原始的引用仍然没变。当obj在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。
  */
  ```

  





## 执行上下文与作用域





## 垃圾回收