> 函数实际上是对象，每个函数都是 Function 类型的实例，而 Function 也有属性和方法，和其他引用类型一样。函数名其实就是指向函数对象的指针，而且不一定与函数本身紧密绑定。
>
> 几种定义函数的方法
>
> 函数声明：`function sum(a, b) {}`
>
> 函数表达式：`let sum = function(a, b) {}`
>
> 箭头函数：`let sum = (a, b) => {}`
>
> Function构造函数：`let sum = new Function('a', 'b', 'return ...')`



## 箭头函数

* ES6新增了胖箭头方式`=>`来定义函数表达式的能力，其与正式的函数表达式行为是相同的。任何可以使用函数表达式的地方，都可以使用箭头函数。
* 箭头函数简洁的语法非常适合嵌入函数的场景。
* 只有一个参数时可以不用括号，没有参数或者多个参数的情况下才要括号。
* 大括号的用法：使用大括号就表示有函数体，可以包含多条语句，如果不使用大括号，那么箭头后面就只能有一行代码，而且省略大括号会隐式返回这行代码的值。
* 虽然简洁，但是也有很多场合不能使用，如箭头函数不能使用`arguments、super、new.target`，也不能用作构造函数。此外，箭头函数也没有 `prototype` 属性







## 函数名

* 函数名就是指向函数的指针，其实就可以进行赋值等一系列操作。
* ES6中所有函数对象都会暴露一个只读的 `name` 属性，大多数情况下其中包含的是一个字符串化的变量名，如果它是用 Function 构造函数创建的，会显示为 `anonymous`







## 理解参数

* ES函数既不关心传入的参数个数，也不关心这些参数的数据类型。定义函数时要接收两个参数，并不意味着调用时就传两个参数。之所以这样，主要是因为ES函数的参数在内部表现为一个数组，这个数组的参数多少函数并不关心。事实上，使用`function`关键字定义（非箭头）函数时，我们可以在函数内部访问 `arguments `对象，从中取得传入的每个参数值。
* `arguments`对象是一个类数组对象（不是Array的实例），可以使用中括号语法访问其中的元素。而且`arguments`对象可以和参数一起使用，而且两者会保持同步。
* 箭头函数中的参数无法使用`arguments`对象，只能通过定义的命名参数访问。如果非要使用，也可以通过包装函数来使用。
* 注意：ES中的所有参数都是按值传递的，不可能按引用传递参数。如果把对象作为参数传递，那么传递的就是这个对象的引用。







## 没有重载

* ES函数不能像传统语言那样重载。Java语言中，函数可以有两个定义，只要签名（接受参数的类型和数量）不同就行，因为ES函数没有函数签名，自然就没有重载。
* ES中定义两个同名函数，后定义的会覆盖先定义的。
* 我们可以通过检查参数的类型和数量，然后分别执行不同的逻辑来模拟函数重载。







## 默认参数值

* ES6之前实现默认参数的一种常用方式就是检测某个参数是否等于 `undefined`，如果是则意味着没有传这个参数，那就给它赋一个值。
* ES6之后就不用这么麻烦了，支持显式定义默认参数。给参数传递`undifined`相当于没有传值，不过这样可以利用多个独立的默认值。
* `arguments`对象始终以调用函数时传入的值为准。
* 默认值也可以使用调用函数返回后的值。
* 默认参数只有在函数被调用时才会求值，不会在函数定义时求值。默认值只有在调用函数但未传相应参数时才会被调用。箭头函数类似，不过不能省略括号。







## 参数扩展与收集

* ES6新增了扩展运算符，对可迭代对象应用扩展运算符，并将其作为一个参数传入，可以将可迭代对象拆分，并将迭代返回的每个值单独传入

  ```js
  console.log(getSum(...values))
  ```

  对函数中的`arguments`对象而言，它并不知道扩展运算符的存在，而是按照调用函数时传入的参数接收每一个值。

* 箭头函数中也可以使用扩展运算符。

* 可以作为收集参数来使用，不过此时只能放在最后使用。`getPro(firstValue, ...values)`，另外，使用收集参数不会影响`arguments`对象，它仍然反映调用时传给函数的参数。

* 箭头函数虽然不支持 `arguments` 对象，但支持收集参数的定义方式，因此也可以实现类似`arguments`一样的逻辑。







## 函数声明和函数表达式



> JS引擎对于 函数声明`function sum(){}` 和 函数表达式`let sum=function(){}` 是区别对待的。JS引擎在任何代码执行以前，会先读取函数声明，并在执行上下文中生成函数定义（也叫函数声明提升）。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。



* 这并不是因为使用 let 导致的，使用 var 关键字也会碰到同样的问题。
* 除了这个区别之外，这两种语法是等价的。







## 函数作为值



> 因为函数名在ES中就是变量，所以函数可以用在任何可以使用变量的地方。这意味着不仅可以把函数作为参数传递给另一个函数，还可以在一个函数中返回另一个函数。



* 要注意的是，如果是访问函数而不是调用函数，那就必须不带括号。因为我们要使用这个函数，而不是它们执行的结果。

* 一个函数中返回另外一个函数也是很有用的。比如，一个对象数组，我们需要根据某个属性来进行排序。我们使用 `sort()` 方法来实现，它需要一个比较函数，如下

  ```js
  function createComparingFunction(porpertyName) {
    return function(obj1, obj2) {
      let value1 = obj1[porpertyName]
      let value2 = obj2[porpertyName]
      
      if (value1 < value2) {
        return -1
      } else if (value1 > value2) {
        return 1
      } else {
        return 0
      }
    }
  }
  
  let data = [
    { name: 'angle', age: 23 },
    { name: 'tage', age: 34 }
  ]
  data.sort(createComparingFunction('name'))
  ```

  







## 函数内部



> ES5中，函数内部存在两个特殊的对象：`arguments` 和 `this` 。
>
> ES6又新增了 `new.target` 属性。



* `arguments` 对象：是一个类数组对象，包含调用时函数内传入的所有参数，这个对象只有以 function 关键字定义函数时才会有。虽然主要用于包含函数参数，但 `arguments` 对象其实还有一个 `callee` 属性，是一个指向 `arguments` 对象所在函数的指针。
* `callee`属性的主要作用是让函数逻辑与函数名解耦。
* `this`对象：它在标准函数和箭头函数中有不同的行为。在标准函数中，this引用的是把函数当成方法调用的上下文对象，这时通常称为“this值”。在箭头函数中，this引用的是定义箭头函数的上下文。在事件回调或定时回调中调用某个函数时，this值指向的并非想要的对象，此时将回调函数写成箭头函数就可以解决问题，这是因为箭头函数中的this会保留定义该函数时的上下文。
* 注：函数名只是保存指针的变量，因此全局定义的`sayColor()`函数和`o.sayColor()`是同一个函数，只不过执行的上下文不同。
* `caller`属性：ES5也会给函数对象添加一个 caller 属性，这个属性引用的是调用当前函数的函数，如果在全局作用域中调用则为null。
* `new.target`属性：ES中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。ES6又新增了检测函数是否使用 new 关键字调用的 `new.target`属性。如果函数是正常调用的，则`new.target`的值是`undefined`，如果是 new 关键字调用的，则`new.target`属性则会指向被调用的构造函数。







## 函数属性和方法



> 前面提到，ES中的函数是对象，因此有属性和方法。每个函数都有两个属性：`length`和`prototype`。其中，`length`属性保存函数定义的命名参数的个数。



* `prototype`属性是ES中最有趣的部分。它是保存引用类型所有实例方法的地方，这意味着`toString()、valueOf()`等方法实际上都保存在 prototype 上，进而由所有的实例共享。该属性不可枚举，所以无法使用 for in 循环。
* 函数还有两个方法：`apply()` 和 `call()`，这两个方法都会以指定的 this值 来调用函数，即会设置调用函数时函数体内的 this对象 的值。真正强大的地方不在于给函数传参，而是控制函数调用上下文即函数内的 this值 的能力。使用它们两个的好处就是可以将任意对象设置为任意函数的作用域，这样对象可以不用关系方法。
* ES5基于同样的考虑定义了一个新方法：`bind()`，该方法会创建一个新的函数实例。其 this值 会被绑定到传给 bind() 的对象。







## 函数表达式



> 函数表达式虽然强大，但也更容易让人迷惑。定义函数的两种方式：函数声明和函数表达式。
>
> 函数声明的特点是**函数声明提升**，函数表达式`let sum = function(){}`看起来就像是一个普通的变量定义和赋值。这样创建的函数叫做匿名函数。



* 记住一点：任何时候，只要函数被当做值来使用，它就是一个函数表达式。







## 递归



> 递归通常的形式是一个函数通过名称调用自己。



```js
function factorial(num) {
  if (num <= 1) {
    return 1
  } else {
    return num * factorial(num - 1)
  }
}
```



* 这是经典的阶乘递归函数，虽然这样写是可以的，但是把这个函数赋值给其他变量就会出问题。在写递归函数时使用`arguments.callee`可以避免这个问题。

* `arguments.callee`是一个指向正在执行的函数的指针，因此可以在函数内部递归调用。因此，在编写递归函数时，`arguments.callee`是引用当前函数的首选。

  ```js
  function factorial(num) {
    if (num <= 1) {
      return 1
    } else {
      return num * arguments.callee(num - 1)
    }
  }
  ```

* 但是严格模式下无法访问`arguments.callee`的，此时可以使用命名函数表达式来解决。即使把函数赋值给另一个变量，函数表达式的名称`f`也不会变，因此递归调用也不会有问题。

  ```js
  const factorial = (function f(num) {
    if (num <= 1) {
      return 1
    } else {
      return num * f(num - 1)
    }
  })
  ```

  



## 尾调用优化

* 如果函数的逻辑允许基于尾调用将其销毁，则引擎就会那么做。
* 尾调用优化的条件就是确定外部栈帧真的没有必要存在了，涉及的条件如下
  * 代码在严格模式下执行（为了防止使用`f.arguments/f.caller`）
  * 外部函数的返回值是对尾调用函数的调用
  * 尾调用函数返回后不需要执行额外的逻辑
  * 尾调用函数不是引用外部函数作用域中自由变量的闭包
* 这个优化在递归场景下的效果是最明显的，因为递归代码最容易在栈内存中迅速产生大量栈帧。
* 可以用来优化生成斐波那契数列的函数。







## 闭包



>  匿名函数通常被人认为是闭包（closure）。
>
> 闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的



* 理解作用域链创建和使用对理解闭包非常重要。

* 在调用一个函数时，会为这个函数调用创建一个执行上下文，并创建一个作用域链，然后初始化这个函数的活动对象AO，外部函数的活动对象是内部函数作用域链上的第二个对象，这个作用域链一直向外串起所有包含函数的活动对象，直到全局执行上下文才终止。

* 函数执行完毕后，局部活动对象会被销毁，内存中就只剩下了全局作用域。不过，闭包就不同了。

* 内部的函数会把外部函数的活动对象添加到自己的作用域中。这样，匿名函数就可以访问到外层函数可以访问的所有变量。

* 一个副作用就是：外层函数的活动对象AO并不能在它执行完毕之后销毁，因为匿名函数中还存在对它的引用。外层函数执行完毕，其执行上下文的作用域链会被销毁，但它的活动对象仍然会保留在内存中，直到匿名函数被销毁后才会销毁。

* 过度使用闭包可能会造成内存过度占用，建议谨慎使用。

* 在闭包中使用`this`会让代码变得复杂，每个函数在被调用时都会自动创建两个特殊变量`this`和`arguments`。内部函数永远不可能直接访问外部函数的这两个变量。但是如果把this保存到闭包可以访问的另一个变量中则是行得通的。

  ```js
  window.identity = 'the window'
  
  let object = {
    identity: 'my obj'
    getIdentityFunc() {
      let that = this
      return function() {
        return that.identity
      }
    }
  }
  
  console.log(object.getIdentityFunc()()) // 'my obj'
  ```

* 内存泄漏：垃圾回收机制以及循环引用问题，不再详谈。









## 立即调用的函数表达式



> 立即调用的匿名函数又被称为立即调用的函数表达式。它类似于函数声明，但由于被包含在括号中，所以会被解释为函数表达式。



```js
(function() {
  //块级作用域
})()
```



* ES5中由于没有块级作用域，使用立即调用表达式可以模拟块级作用域是非常普遍的。

* 在ES6之后，可以不使用该方法来实现块级作用域了，可以使用如下方式

  ```js
  {
    let i 
    for (i = 0; i < count; i++) {
      console.log(i)
    }
  }
  ```

* 立即调用表达式（也叫立即执行函数）一个实际的用途，就是可以使用它来锁定参数值。循环添加多个点击事件，且使用var关键字时用到，把当前的索引值通过立即执行函数传递进去。







## 私有变量



> 任何定义在函数或块中的变量，都可以认为是公有的。因为这个函数或块的外部无法访问其中的变量。私有变量包括函数参数，局部变量，以及函数内部定义的其他函数。