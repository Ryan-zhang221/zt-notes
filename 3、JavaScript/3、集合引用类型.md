## Object

* 对象中属性的读取两种方式：`. 和 []`其中后者的优势在于可以通过变量访问属性，或者属性中有可能导致语法错误的情况下。
* 后续详细解析对象。


## Array

* ES6新增的两个创建数组的静态方法`Array.from()`和`Array.of()`，分别表示将类数组结构转换为数组实例和将一组参数转换为数组实例，用法如下：

  ```js
  // 拆分字符串
  console.log(Array.from("matt")) // ['m', 'a', 't', 't']
  
  // 对现有数组进行浅复制
  const a1 = [1,2,3,4]
  const a2 = Array.from(a1)
  console.log(a2) // [1,2,3,4]
  alert(a1 === a2) // false
  
  // arguments对象可以被轻松转换为数组
  function getData() {
    return Array.from(arguments)
  }
  console.log(getData([1,2,3,4])) // [1,2,3,4]
  ```

* 数组空位：不建议使用

* 数组索引：数组中元素的数量保存在`length`属性中，这个属性始终返回0或者大于0的值。且length属性的独特之处在于它不只是只读的。通过修改length属性，可以从数组末尾删除或添加元素，新添加的元素会以undefined填充。

* 检测数组：一个经典问题：判断一个对象是不是数组，在一个网页的情况下（一个全局作用域），使用`instanceof`关键字足矣，`value instanceof Array`。如果有多个全局执行上下文，则出现了`isArray`方法，`Array.isArray(value)`

* 迭代器方法：ES6中，Array原型上出现了3个用于检索数组内容的方法：`keys()、values()、entries()`

  ```js
  const a = ['foo', 'bar', 'baz', 'qux']
  
  const aKeys = Array.from(a.keys())
  const aValues = Array.from(a.values())
  const aEntries = Array.from(a.entries())
  
  console.log(aKeys) // [0,1,2,3]
  console.log(aValues) // ["foo", "bar", "baz", "qux"]
  console.log(aEntries) // [[0, "foo"], [1, "bar"], [2, "baz"], [3, "qux"]]
  
  // 使用ES6的解构可以方便从循环中拆分键值对
  for (const [idx, ele] of a.entries()) {
    console.log(idx, ele)
  }
  ```

* 复制和填充方法：ES6新增批量复制方法`copyWithin()`和填充数组方法`fill()`

* 转换方法
  * `toLocalString()`
  * `toString()`
  * `valueOf`

* 栈方法：后进先出的一种数据结构，叠起来的盘子

  * `push()`
  * `pop()`这里注意 Arrya.pop() 的值就是被移出的那一项

* 队列方法：先进先出的一种数据结构

  * `shift()`：数组前移除
  * `unshift()`：数组前增加

* 排序方法：

  * `reverse()`：将数组元素反向排列
  * `sort()`：默认情况下，sort会按照升序重新排列元素，在排序前它会把每一项转换为字符串然后比较。该方法可以接受一个比较函数，用于判断哪个值应该排在前面。基本逻辑：比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值，如果两个参数相等就返回0，否则返回正值。

    ```js
    function compare(value1, value2) {
      if (value1 < value2) {
        return -1
      } else if (value > value2) {
        return 1
      } else {
        return 0
      }
    }
    
    // 简写如下
    values.sort((a,b) => a < b ? 1 : a > b ? -1 : 0)
    
    // 如果是数值，还可以如下简写
    function compare(value1, value2) {
      return value2 - value1
    }
    ```

* 操作方法

  * `concat()`：连接数组
  * `slice()`：截取数组一部分
  * `splice()`：使用方式有很多种，主要目的用来给数组中间插入元素
    * 删除：需要传入2个参数
    * 插入：需要传入3个参数
    * 替换：需要传入3个参数

* 搜索和位置方法
	* 提供两类搜索数组的方法：按严格相等搜索和断言函数搜索
	* 严格相等搜索：都会使用`===`进行比较
	  * `indexOf()`：返回要查找的元素在数组中的位置，如果没找到就返回-1
	  * `lastIndexOf()`：同上，不过从最后一项向前搜索
	  * `includes()`ES7新增，返回布尔值
	* 断言函数搜索：允许按照定义的断言函数进行搜索
	  * `find()`返回第一个匹配的元素，找到后不会继续搜索
	  * `findIndex()`返回第一个匹配元素的索引

* 迭代方法（遍历）
	* `every()`：如果对每一项，传入函数都返回true，则返回true
	* `filter()`：对传入函数返回true的项会组成数组之后返回
	* `forEach()`：对每一项执行给定函数，无返回值
	* `map()`：返回由每次传入函数调用的结果构成的数组
	* `some()`：如果有一项，传入函数返回true，则该方法返回true

* 归并方法：迭代数组的所有项，并在此基础上构建一个最终返回值。
	* `reduce()`
	* `reduceRight()`
* 定型数组




## Map映射

JS中实现"键/值"存储数据的话可以使用Object来高效完成，但是这种方式也有自己的局限

* ES6新增的`Map`是一种新的集合类型，为这门语言带来了真正的键/值存储机制。
* 基本API：
  * `set()`方法添加键值对
  * `get() has()`方法来进行查询
  * `size`属性获取映射中的键值对数量
  * `delete() clear()`方法删除值
* 与Object的一个主要差异：`Map`实例会维护键值对的插入顺序，因此可以根据插入顺序进行迭代操作。
* `Map`与`Object`的选择：对于大多数问题，两个区别不大，但是对于追求性能和内存的开发者而言，两者还是有较大差别
  * 内存占用：给定固定大小的内存，Map大约可以比Object多存储50%的键值对；
  * 插入性能：不会有太大差别，如果代码涉及大量插入操作，应该选择Map；
  * 查找速度：代码涉及大量查找操作，某些情况（连续整数为属性，浏览器引擎会进行优化）下Object更好；
  * 删除性能：delete删除Object属性的性能一直较差，Map的delete()操作都比插入和查找更快，如果代码涉及大量删除操作，那么毫无疑问应该选择Map；

## WeakMap弱映射

* 一种新的集合类型，是一种增强的键值对存储机制，其中`weak`的意思是JS垃圾回收程序对待弱映射中键的方式
* 弱映射中的键只能是 Object 或者继承自 Object 的类型，尝试使用非对象设置键会报错。
* `weak`表示弱映射的键是"弱弱的拿着"，即这些键不属于正式的引用，不会阻止垃圾回收，但是weakMap中的引用可不是"弱弱的拿着"，不会被当做垃圾回收。
* weakMap中的键值对随时都有可能被摧毁，所以不可迭代键。
* weanMap之所以限制只能用对象作为键，是为了保证只有通过键对象的引用才能取得值。如果允许原始值，那就没有办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了
* 应用：私有变量、DOM节点元数据

## Set

* 一种新的集合类型，为这门语言带来了集合数据结构，很多方向像是加强的Map，很多API和行为都是共有的。

## WeakSet