## 理解对象

* ES定义对象为一组属性的无序集合，可以理解为一张散列表，其中的内容就是一组键值对，值可以是数据或者函数。

* 属性的类型：数据属性和访问器属性

  * 《数据属性》：包含一个保存数据值的位置，值会从这个位置读取也会写入到这个位置，有4个特性如下

    * `[[Configurable]]`：表示属性是否可以通过 delete 删除，默认为 true
    * `[[Enumerable]]`：表示属性是否可以通过 for-in 循环返回，默认为 true
    * `[[Writable]]`：属性的值是否能被修改，默认为 true
    * `[[Value]]`：包含属性实际的值，即上述提到的读取和写入属性值的位置

  * 要修改属性的默认特性，就要使用`Object.defineProperty()`方法

    ```js
    let person = {}
    Object.defineProperty(person, "name", {
      writable: false,
      value: 'ryan'
    })
    ```

  * 多数情况下，我们可能用不到这个方法，但是要理解JS对象，就要理解这些概念。

  * 《访问器属性》：访问器属性不包含数据值，反而包含一个获取（getter）函数和设置（setter）函数。这两个值不是必需的。访问器属性不能直接定义，必须使用`Object.defineProperty()`方法。如下是访问器属性的典型使用方法，即设置一个属性值会导致一些其他变化发生。

    ```js
    let book = {
      year_: 2017, // 私有成员
      edition: 1 // 公共成员
    }
    
    Object.defineProperty(book, "year", {
      get() {
        return this.year_
      },
      set(newValue) {
        if (newValue > 2017) {
          this.year_ = newValue
          this.edition += newValue - 2017
        }
      }
    })
    
    book.year = 2020
    console.log(book.edition) // 4
    ```


* 定义多个属性：`Object.defineProperties()`，可以同时定义数据属性和访问器属性

* 合并对象：ES6专门为合并对象提供了`Object.assign(目标对象，源对象)`方法，该方法实际对每个源对象执行的是浅复制。如果赋值之间出错，会终止并退出，它是一个尽力而为，可能只会完成部分复制的操作。

* 增强的对象语法：极其有用的语法糖，提升了处理对象的方便程度

  * 属性值简写：给对象添加变量的时候，经常会遇到属性名和变量名一样的情况，这时我们可以不使用冒号，就会被自动解析为同名的属性值。代码压缩程序会保留属性名，防止找不到。

    ```js
    let name = "Matt"
    
    // 原本写法
    let person = {
      name: name
    }
    // ES6新增属性值简写
    let person = {
      name
    }
    
    console.log(person.name) // Matt
    ```

  * 可计算属性：在引入可计算属性之前，如果使用变量的值作为属性，必须先声明对象，然后使用中括号的语法来添加属性。即不能在对象字面量中直接动态命名属性。有了可计算属性，就可以在对象字面量中完成动态属性赋值，中括号包围的对象属性键告诉运行时将其作为JS表达式而不是字符串来求值

    ```js
    const nameKey = 'name'
    const ageKey = 'age'
    const jobKey = 'job'
    const uniqueToken = 0
    
    function getUniqueKey(key) {
      return `${key}_${uniqueKey++}`
    }
    
    let person = {
      [getUniqueKey(nameKey)]: 'ryan',
      [getUniqueKey(ageKey)]: 23,
      [getUniqueKey(jobKey)]: 'software engineer'
    }
    
    console.log(person) // {name_0: 'ryan', age_1: 23, job_3: 'software engineer'}
    ```

  * 简写方法名：给对象定义方法时，通常都需要写一个方法名、冒号，然后引用一个匿名函数表达式。get 和 set 函数同样适用。可以与可计算属性兼容。

    ```js
    // 之前的写法
    let person = {
      sayName: function(name) {
        console.log(`my name is ${name}`)
      }
    }
    
    // 简写方法名
    let person = {
      sayName(name) {
        console.log(`my name is ${name}`)
      }
    }
    
    // get 和 set 函数
    let person = {
      get name() {
        ...
      },
      set name(name) {
        ...
      }
    }
        
    // 兼容可计算属性
    const methodKey = 'sayName'
    let person = {
      [methodKey](name) {
        console.log(`my name is ${name}`)
      }
    }
    person.sayName('ryan') // my name is ryan
    ```

  * 对象解构：在一条语句中嵌套数据实现一个或多个赋值操作

    * 简写语法`let {name, age} = person`
    * 引用不存在是默认复制`undefined`
    * 定义默认值`let {name, pich="hello"} = person`



## 创建对象

* 





## 继承







## 类

