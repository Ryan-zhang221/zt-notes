## 理解对象

* ES定义对象为一组属性的无序集合，可以理解为一张散列表，其中的内容就是一组键值对，值可以是数据或者函数。

* 属性的类型：数据属性和访问器属性

  * 《数据属性》：包含一个保存数据值的位置，值会从这个位置读取也会写入到这个位置，有4个特性如下

    * `[[Configurable]]`：表示属性是否可以通过 delete 删除，默认为 true
    * `[[Enumerable]]`：表示属性是否可以通过 for-in 循环返回，默认为 true
    * `[[Writable]]`：属性的值是否能被修改，默认为 true
    * `[[Value]]`：包含属性实际的值，即上述提到的读取和写入属性值的位置

  * 要修改属性的默认特性，就要使用`Object.defineProperty()`方法

    ```js
    let person = {}
    Object.defineProperty(person, "name", {
      writable: false,
      value: 'ryan'
    })
    ```

  * 多数情况下，我们可能用不到这个方法，但是要理解JS对象，就要理解这些概念。

  * 《访问器属性》：访问器属性不包含数据值，反而包含一个获取（getter）函数和设置（setter）函数。这两个值不是必需的。访问器属性不能直接定义，必须使用`Object.defineProperty()`方法。如下是访问器属性的典型使用方法，即设置一个属性值会导致一些其他变化发生。

    ```js
    let book = {
      year_: 2017, // 私有成员
      edition: 1 // 公共成员
    }
    
    Object.defineProperty(book, "year", {
      get() {
        return this.year_
      },
      set(newValue) {
        if (newValue > 2017) {
          this.year_ = newValue
          this.edition += newValue - 2017
        }
      }
    })
    
    book.year = 2020
    console.log(book.edition) // 4
    ```


* 定义多个属性：`Object.defineProperties()`，可以同时定义数据属性和访问器属性

* 合并对象：ES6专门为合并对象提供了`Object.assign(目标对象，源对象)`方法，该方法实际对每个源对象执行的是浅复制。如果赋值之间出错，会终止并退出，它是一个尽力而为，可能只会完成部分复制的操作。

* 增强的对象语法：极其有用的语法糖，提升了处理对象的方便程度

  * 属性值简写：给对象添加变量的时候，经常会遇到属性名和变量名一样的情况，这时我们可以不使用冒号，就会被自动解析为同名的属性值。代码压缩程序会保留属性名，防止找不到。

    ```js
    let name = "Matt"
    
    // 原本写法
    let person = {
      name: name
    }
    // ES6新增属性值简写
    let person = {
      name
    }
    
    console.log(person.name) // Matt
    ```

  * 可计算属性：在引入可计算属性之前，如果使用变量的值作为属性，必须先声明对象，然后使用中括号的语法来添加属性。即不能在对象字面量中直接动态命名属性。有了可计算属性，就可以在对象字面量中完成动态属性赋值，中括号包围的对象属性键告诉运行时将其作为JS表达式而不是字符串来求值

    ```js
    const nameKey = 'name'
    const ageKey = 'age'
    const jobKey = 'job'
    const uniqueToken = 0
    
    function getUniqueKey(key) {
      return `${key}_${uniqueKey++}`
    }
    
    let person = {
      [getUniqueKey(nameKey)]: 'ryan',
      [getUniqueKey(ageKey)]: 23,
      [getUniqueKey(jobKey)]: 'software engineer'
    }
    
    console.log(person) // {name_0: 'ryan', age_1: 23, job_3: 'software engineer'}
    ```

  * 简写方法名：给对象定义方法时，通常都需要写一个方法名、冒号，然后引用一个匿名函数表达式。get 和 set 函数同样适用。可以与可计算属性兼容。

    ```js
    // 之前的写法
    let person = {
      sayName: function(name) {
        console.log(`my name is ${name}`)
      }
    }
    
    // 简写方法名
    let person = {
      sayName(name) {
        console.log(`my name is ${name}`)
      }
    }
    
    // get 和 set 函数
    let person = {
      get name() {
        ...
      },
      set name(name) {
        ...
      }
    }
        
    // 兼容可计算属性
    const methodKey = 'sayName'
    let person = {
      [methodKey](name) {
        console.log(`my name is ${name}`)
      }
    }
    person.sayName('ryan') // my name is ryan
    ```

  * 对象解构：在一条语句中嵌套数据实现一个或多个赋值操作
		
		* `let{ name: personName, age: personAge } = person`
    * 简写语法`let {name, age} = person`
    * 引用不存在时默认赋值undefined`
    * 定义默认值`let {name, pich="hello"} = person`
    * 在对象结构的上下文中，原始值会被当成对象。调用了ToObject()
    * 如果给实现声明好的变量赋值，则赋值表达式必须包含在一对括号中
    * 嵌套解构：解构赋值可以使用嵌套结构，以匹配嵌套的属性
    * 部分解构：如果解构时报错，则整个解构赋值只会完成一部分。
    * 允许参数中解构



## 创建对象

* Object构造函数和对象字面量的方式可以方便创建对象，但是创建多个对象时要重复编写很多代码

* 工厂模式：解决了创建多个类似对象的问题，但是没有解决对象标识问题（即新创建的对象是什么类型）

  ```js
  function createPerson（name, age, job） {
    let o = new Object()
    o.name = name
    o.age = age
    o.job = job
    return o
  }
  let person1 = createPerson('ryan', 23, 'software enigneer')
  ```

* 构造函数模式：构造函数是用来创建特定类型对象的，比如像`Object`和`Array`这样的原生构造函数，也可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。`new`操作符做了如下操作：

  * 内存中创建一个新对象
  * 新对象内部的`[[Prototype]]`特性被赋值为构造函数的`prototype`属性
  * 构造函数内部的`this`指向新对象
  * 执行构造函数内部的代码（即给新对象添加属性）
  * 如果构造函数返回非空对象，则返回该对象，否则，返回刚创建的对象

  ```js
  function Person(name, age, job) {
    this.name = name
    this.age = age
    this.job = job
  }
  let person1 = new Person('ryan', 23, 'software enigneer')
  ```

  * 使用`new`操作符创建的对象（也叫构造函数的一个实例）都有一个`constructor`属性指向构造函数 Person，`person1.constructor === Person // true`
  * `instanceof`操作符是确定对象类型更可靠的方式`person1 instanceof Person // true`这就说明自定义构造函数可以确保实例被标识为特定类型，相比较于工厂模式，这时一个很大的好处
  * 注：构造函数也是函数，唯一的区别就是调用方式不同
  * 问题：构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍，每个实例上的同名函数却不是同一个Function实例，因为都是做一样的事，所以没必要定义两个不同的Function实例，要解决这个问题，可以把函数定义转移到构造函数外部。这样虽然解决了现有问题，但是全局作用域就会被搞乱了，且如果有多个方法，就要在全局作用域定义多个函数，这会导致自定义类型引用的代码不能很好的聚集在一起，这个问题可以使用原型模式来很好的解决。

* 原型模式：





## 继承







## 类

