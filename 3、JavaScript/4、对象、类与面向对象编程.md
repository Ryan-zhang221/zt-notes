## 理解对象

* ES定义对象为一组属性的无序集合，可以理解为一张散列表，其中的内容就是一组键值对，值可以是数据或者函数。

* 属性的类型：数据属性和访问器属性

  * 《数据属性》：包含一个保存数据值的位置，值会从这个位置读取也会写入到这个位置，有4个特性如下

    * `[[Configurable]]`：表示属性是否可以通过 delete 删除，默认为 true
    * `[[Enumerable]]`：表示属性是否可以通过 for-in 循环返回，默认为 true
    * `[[Writable]]`：属性的值是否能被修改，默认为 true
    * `[[Value]]`：包含属性实际的值，即上述提到的读取和写入属性值的位置

  * 要修改属性的默认特性，就要使用`Object.defineProperty()`方法

    ```js
    let person = {}
    Object.defineProperty(person, "name", {
      writable: false,
      value: 'ryan'
    })
    ```

  * 多数情况下，我们可能用不到这个方法，但是要理解JS对象，就要理解这些概念。

  * 《访问器属性》：访问器属性不包含数据值，反而包含一个获取（getter）函数和设置（setter）函数。这两个值不是必需的。访问器属性不能直接定义，必须使用`Object.defineProperty()`方法。如下是访问器属性的典型使用方法，即设置一个属性值会导致一些其他变化发生。

    ```js
    let book = {
      year_: 2017, // 私有成员
      edition: 1 // 公共成员
    }
    
    Object.defineProperty(book, "year", {
      get() {
        return this.year_
      },
      set(newValue) {
        if (newValue > 2017) {
          this.year_ = newValue
          this.edition += newValue - 2017
        }
      }
    })
    
    book.year = 2020
    console.log(book.edition) // 4
    ```


* 定义多个属性：`Object.defineProperties()`，可以同时定义数据属性和访问器属性

* 合并对象：ES6专门为合并对象提供了`Object.assign(目标对象，源对象)`方法，该方法实际对每个源对象执行的是浅复制。如果赋值之间出错，会终止并退出，它是一个尽力而为，可能只会完成部分复制的操作。

* 增强的对象语法：极其有用的语法糖，提升了处理对象的方便程度

  * 属性值简写：给对象添加变量的时候，经常会遇到属性名和变量名一样的情况，这时我们可以不使用冒号，就会被自动解析为同名的属性值。代码压缩程序会保留属性名，防止找不到。

    ```js
    let name = "Matt"
    
    // 原本写法
    let person = {
      name: name
    }
    // ES6新增属性值简写
    let person = {
      name
    }
    
    console.log(person.name) // Matt
    ```

  * 可计算属性：在引入可计算属性之前，如果使用变量的值作为属性，必须先声明对象，然后使用中括号的语法来添加属性。即不能在对象字面量中直接动态命名属性。有了可计算属性，就可以在对象字面量中完成动态属性赋值，中括号包围的对象属性键告诉运行时将其作为JS表达式而不是字符串来求值

    ```js
    const nameKey = 'name'
    const ageKey = 'age'
    const jobKey = 'job'
    const uniqueToken = 0
    
    function getUniqueKey(key) {
      return `${key}_${uniqueKey++}`
    }
    
    let person = {
      [getUniqueKey(nameKey)]: 'ryan',
      [getUniqueKey(ageKey)]: 23,
      [getUniqueKey(jobKey)]: 'software engineer'
    }
    
    console.log(person) // {name_0: 'ryan', age_1: 23, job_3: 'software engineer'}
    ```

  * 简写方法名：给对象定义方法时，通常都需要写一个方法名、冒号，然后引用一个匿名函数表达式。get 和 set 函数同样适用。可以与可计算属性兼容。

    ```js
    // 之前的写法
    let person = {
      sayName: function(name) {
        console.log(`my name is ${name}`)
      }
    }
    
    // 简写方法名
    let person = {
      sayName(name) {
        console.log(`my name is ${name}`)
      }
    }
    
    // get 和 set 函数
    let person = {
      get name() {
        ...
      },
      set name(name) {
        ...
      }
    }
        
    // 兼容可计算属性
    const methodKey = 'sayName'
    let person = {
      [methodKey](name) {
        console.log(`my name is ${name}`)
      }
    }
    person.sayName('ryan') // my name is ryan
    ```

  * 对象解构：在一条语句中嵌套数据实现一个或多个赋值操作
		
		* `let{ name: personName, age: personAge } = person`
    * 简写语法`let {name, age} = person`
    * 引用不存在时默认赋值undefined`
    * 定义默认值`let {name, pich="hello"} = person`
    * 在对象结构的上下文中，原始值会被当成对象。调用了ToObject()
    * 如果给实现声明好的变量赋值，则赋值表达式必须包含在一对括号中
    * 嵌套解构：解构赋值可以使用嵌套结构，以匹配嵌套的属性
    * 部分解构：如果解构时报错，则整个解构赋值只会完成一部分。
    * 允许参数中解构



## 创建对象

* Object构造函数和对象字面量的方式可以方便创建对象，但是创建多个对象时要重复编写很多代码

* 工厂模式：解决了创建多个类似对象的问题，但是没有解决对象标识问题（即新创建的对象是什么类型）

  ```js
  function createPerson（name, age, job） {
    let o = new Object()
    o.name = name
    o.age = age
    o.job = job
    return o
  }
  let person1 = createPerson('ryan', 23, 'software enigneer')
  ```

* 构造函数模式：构造函数是用来创建特定类型对象的，比如像`Object`和`Array`这样的原生构造函数，也可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。`new`操作符做了如下操作：

  * 内存中创建一个新对象
  * 新对象内部的`[[Prototype]]`特性被赋值为构造函数的`prototype`属性
  * 构造函数内部的`this`指向新对象
  * 执行构造函数内部的代码（即给新对象添加属性）
  * 如果构造函数返回非空对象，则返回该对象，否则，返回刚创建的对象

  ```js
  function Person(name, age, job) {
    this.name = name
    this.age = age
    this.job = job
  }
  let person1 = new Person('ryan', 23, 'software enigneer')
  ```

  * 使用`new`操作符创建的对象（也叫构造函数的一个实例）都有一个`constructor`属性指向构造函数 Person，`person1.constructor === Person // true`
  * `instanceof`操作符是确定对象类型更可靠的方式`person1 instanceof Person // true`这就说明自定义构造函数可以确保实例被标识为特定类型，相比较于工厂模式，这时一个很大的好处
  * 注：构造函数也是函数，唯一的区别就是调用方式不同
  * 问题：构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍，每个实例上的同名函数却不是同一个Function实例，因为都是做一样的事，所以没必要定义两个不同的Function实例，要解决这个问题，可以把函数定义转移到构造函数外部。这样虽然解决了现有问题，但是全局作用域就会被搞乱了，且如果有多个方法，就要在全局作用域定义多个函数，这会导致自定义类型引用的代码不能很好的聚集在一起，这个问题可以使用原型模式来很好的解决。

* 原型模式：每个函数都会创建一个prototype属性，该属性是一个对象，包含特定引用类型的实例共享的属性和方法。

  ```js
  let Person = function() {}
  
  Person.prototype.name = 'ryan'
  Person.prototype.age = 23
  Person.prototype.job = 'software engineer'
  
  let person1 = new Person()
  console.log(person.name) // ryan
  ```

  * 不论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个 prototype 属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为 constructor 的属性，指向其构造函数。实例无法找到其构造函数，但是可以找到其构造函数的原型对象。（可以通过画图来理清关系）
  * 在对象内部访问属性时，会按照这个属性的名称开始搜索，搜索开始于对象实例本身，如果该实例上发现了，则返回对应的值，如果没有发现则搜索会沿着指针进入原型对象，再寻找。
  * 实例对象可以通过`__ptoto__`来访问原型对象，然后通过原型对象的`constructor`属性来访问其构造函数。
  * 虽然可以通过实例读取原型对象上的值，但是不能通过实例重写这些值。给实例添加一个与原型对象同名的属性后，搜索时就不会搜索原型对象了，其实就是遮蔽了原型对象上的同名属性，也就是说不会修改它，但是会屏蔽对它的访问。
  * `in`操作符和`hasOwnproperty()`方法：in操作符会在可以通过对象访问指定属性时返回true，不论该属性在实例上还是原型上。而hasOwnProperty()方法只有属性存在于实例上时才返回true。所以只要in操作符返回true，而hasOwnProperty()返回false，就可以说明该属性是一个原型属性。
  * `for-in`循环中使用的in操作符可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。

* 对象迭代：在JS有史以来的绝大部分时间里，迭代对象都是一个难题。ES2017新增了两个静态方法，用于将对象内容转换为序列化（可迭代）的格式，分别是`Object.values()`方法和`Object.entries()`方法。前者返回对象值的数组，后者返回键值对的数组.

  * 其他原型写法`Person.prototype = {name: 'ryan', age: 23}`，这种方式的写法construntor属性不会指向Person属性了，需要手动重新设置一下constructor属性的值为Person
  * 原型的动态性：即使实例在修改原型之前已经存在，任何时候对原型对象的修改也会在实例上反映出来。重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。记住，实例只有指向原型的指针，没有指向构造函数的指针。实例的指针是在调用构造函数时自动赋值的，这个指针即使把原型对象修改为不同的对象也不会变。重写构造函数上的原型之后再创建的实例才会引用新的原型，而在此之前创建的实例仍然会引用最初的原型。
  * 原生对象原型：所有原生引用类型的构造函数（Object、Array、String等）都在原型上定义了实例方法。也可修改原生对象原型，可以随时添加方法，但不推荐。推荐的做法是创建一个自定义的类，继承原生类型。
  * 原型的问题：原型最大的问题在于它的__共享特性__，即修改原型对象中的引用属性时，其余实例也会反映出来。不同的实例应该有属于自己的属性副本。





## 继承

* ES主要是通过原型链实现继承的
* 原型链继承基本思想：通过原型继承多个引用类型的属性的方法。构造函数原型实例的关系为每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向了另一个原型，相应另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。
* 读取实例上的属性时，首先在实例上搜索，如果没有找到则会搜索原型，有了原型链，则会沿着原型链搜索。所有引用类型都继承自`Object`，任何函数的默认原型都是一个 Object 的实例。
* 以对象字面量的方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链。
* 原型链的问题：和之前原型类似，主要问题出现在原型中包含引用值的时候会在所有实例之间共享。这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。第二个问题为子类型在实例化时不能给父类型的构造函数传参。这两个问题导致了原型链不会被单独使用。
* 盗用构造函数继承：
* 组合继承：
* 原型式继承：
* 寄生式继承：
* 寄生式组合继承：




## 类

