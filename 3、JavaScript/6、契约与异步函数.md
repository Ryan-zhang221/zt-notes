## 异步编程

* 同步编程中每一条指令都是在单个线程中按顺序执行的。
* 异步行为相当于系统中断。异步操作通常是必要的，因为强制进程等待一个长时间的操作通常是不可行的。如果代码要访问一些高延迟的资源，通常是向远程服务器发送资源并等待响应。
* 为了让后续代码能够执行，通常需要在异步操作之后通知其他代码。
* 设计一个可以知道变量什么时候可以读取的系统是非常难的，JS经历了几个迭代。
* 首先，早期的JS通常支持回调函数来表明异步操作的完成，如果多个异步操作就有可能造成回调地狱问题。







## 契约（Promise）

* 契约（Promise）的出现完美实现了 Promise/A+ 规范。ES6新增的引用类型 `Promise`，可以通过`new`操作符来实例化。创建时需要传入执行器函数作为参数。Promise 是一个有状态的对象，它可能处于以下三种状态之一：
  * pending（Promise 的初始状态，可以变为以下两种状态且无法改变）
  * fulfilled/resolved
  * rejected
* 契约的状态是私有的，不能通过JS检测到，这主要是为了避免根据读取到的契约状态，以同步的方式处理契约对象。契约状态也不能被外部JS代码修改，原因同上。契约故意将异步行为封装起来，从而隔离外部的同步代码。
* Promise 主要有两个用途：
  * 抽象地表示一个异步操作。
  * Promise 封装的异步操作会实际生成某个值。 









## 异步函数（async/await）

> ES8新增的，它是ES6契约模式在ES函数中的应用，它从行为和语法上都增强了JS，让以同步方式写的代码能够异步执行。它是为了解决我们使用Promise时，后续代码都要写在.then方法中，如下
>
> ```js
> let p = new Promise((resolve, reject) => setTimeout(resolve, 1000, 3))
> p.then((x) => console.log(x))
> ```
>
> 后续代码都需要放在一个函数中，为此，ES8提供了async/await关键字



* `async`关键字用于声明异步函数，该关键字可以用在函数声明，函数表达式，箭头函数和方法上。该关键字可以让函数具有异步特征，但是代码仍然是异步求值的。在参数和闭包方面，异步函数仍然具有普通JS函数的正常行为。

  ```js
  async function foo() {}
  let bar = async function() {}
  let baz = async () => {}
  class Qux {
    async qux() {}
  }
  ```


* 如果异步函数使用了`return`关键字返回了值（没有return则会返回undefined），这个值会被`Promise.resolve()`包装成一个契约对象。异步函数始终返回契约对象Promise，在函数外部调用这个函数可以得到它返回的Promise，进而可以使用`.then`方法进行“解包”

* 因为异步函数主要针对不会马上完成的任务，所以自然需要一种暂停和恢复执行的能力，使用`await`关键字可以暂停异步函数代码的执行，等待Promise解决。`await`关键字会暂停执行异步函数后面的代码，让出JS运行时的执行线程。该行为与生成器函数中的`yield`关键字是一样的。`await`关键字同样是尝试“解包”对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行。

* `await`关键字的用法与JS的一元操作符一样，可以单独使用，也可以在表达式中使用

  ```js
  async function foo() {
    console.log(await Promise.resolve('foo'))
  }
  foo() // foo
  
  async function baz() {
    await new Promise((resolve, reject) => setTimeout(resolve, 1000))
    console.log('baz')
  }
  baz() // baz(1000ms后)
  ```

* `await`的限制：`await`关键字必须在异步函数中使用，不能在顶级上下文如`<script>`标签或模块中使用，不过，定义立即调用异步函数是没问题的。

  ```js
  (async function() {
    console.log(await Promise.resolve(3))
  })()
  ```

* 异步函数的特质不会扩展到嵌套函数中，故`await`关键字只能直接出现在异步函数的定义中，在同步函数内部使用则会报错`SyntaxError`

* `async/await`中真正起作用的是`await`，而`async`关键字不管怎么看都像是一个标识符，毕竟异步函数内部如果不使用`await`关键字，其执行基本上和普通函数没有什么区别。要真正理解`await`关键字，必须知道它并非只是等待一个值可用这么简单！

  * JS在运行时在碰到`await`关键字时，会记录在哪里暂停执行，等到`await`右边的值可用了，JS运行时会向消息队列中推送一个任务，这个任务会恢复异步函数的执行。因此，即使`await`后面跟着一个立即可用的值，函数的其余部分也会被异步求值。

    ```js
    async function foo() {
      console.log(2)
      await null
      console.log(4)
    } 
    console.log(1)
    foo()
    console.log(3)
    
    // 1 2 3 4
    
    // 控制台中输出的结果顺序很好的解释了运行时的工作过程
    /*
    	1、打印1
    	2、调用异步函数foo（）
    	3、在foo（）中打印2
    	4、在foo（）中 await 关键字暂停执行，为立即可用的值null向消息队列中添加一个任务
    	5、foo（）退出
    	6、打印3
    	7、同步线程的代码执行完毕
    	8、JS运行时从消息队列中取出任务，恢复异步函数执行
      9、在foo（）中恢复执行，await 取得 null 值（这里并没有使用）
      10、在foo（）中打印4
      11、foo()返回
    */
    ```

  * 如果`await`后面跟着的是一个Promise，问题会稍微复杂一些，此时为了执行异步函数就，实际上会有两个任务被添加到消息队列并被异步求值。

    ```js
    async function foo() {
      console.log(2)
      console.log(await Promise.resolve(8))
      console.log(9)
    }
    async function bar() {
    	console.log(4)
      console.log(await 6)
      console.log(7)
    }
    console.log(1)
    foo()
    console.log(3)
    bar()
    console.log(5)
    
    // 1 2 3 4 5 6 7 8 9
    // 运行时真正的执行顺序如下
    /*
    	1、打印1
    	2、调用异步函数foo()
    	3、在foo()中打印2
    	4、在foo()中 await 关键字暂停执行，向消息队列中添加一个 Promise 在落定之后执行的任务
    	5、Promise 立即落定，把给 await 提供值的任务添加到消息队列
    	6、foo()退出
    	7、打印3
    	8、调用异步函数bar()
    	9、在bar()中打印4
    	10、在bar()中 await 关键字暂停执行，为立即可用的值6向消息队列中添加一个任务
    	11、bar()退出
    	12、打印5
    	13、顶级线程执行完毕
    	14、JS运行时从消息队列中取出解决 await 契约的处理程序，并将解决的值8提供给它
    	15、JS运行时向消息队列中添加一个恢复执行foo()函数的任务
    	16、JS运行时从消息队列中取出恢复执行bar()的任务以及值6
    	17、在bar()函数中恢复执行，await取得值6
    	18、在bar()函数中打印6
    	19、在bar()函数中打印7
    	20、bar()返回
    	21、异步任务完成，JS从消息队列中取出恢复执行foo()的任务以及值8
    	22、在foo()中打印8
    	23、在foo()中打印9
    	24、foo()返回
    	
    	
    	TC39对await后面是promise的情况做了修改，新版浏览器对于该示例的结果返回是123458967，实际开发中，对于异步操作我们通常更关注结果，不依赖执行顺序
    */
    ```

* 异步函数策略：因为简单实用，异步函数很快成为使用广泛的特性之一，不过在使用异步函数时，还是要注意一些问题


  * 实现`sleep()`

    ```js
    async function sleep(delay) {
      return new Promise((resolve) => setTimeout(resolve, delay))
    }
    
    async function foo() {
      const t0 = Date.now()
      await sleep(1500)
      console.log(Date.now() - t0)
    }
    
    foo() // 1502
    ```

  * 利用平行执行

  * 串行执行Promise

  * 栈追踪与内存管理：即 Promise 和 awync/await 的区别主要是在于性能，后者性能能好点。









## 小结




* 契约Promise的主要功能是为异步代码提供了清晰的抽象。可以用契约表示异步执行的代码块，也可以用契约表示异步计算的值。在需要串行异步代码时，契约的价值最为突出。作为可塑性极强的一种结构，契约可以被序列化、连锁使用、复合、扩展和重组。异步函数是将契约应用于JS函数的结果。异步函数可以暂停执行，而不阻塞主线程。无论是编写基于契约的代买，还是组织串行或平行执行的异步代码。使用异步函数都非常得心应手。异步函数可以说是现代JS工具箱中最重要的工具之一。