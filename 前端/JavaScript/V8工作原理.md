## 栈空间和堆空间：数据是如何储存的？

开始之前我们要理解一些概念：
* 静态语言：在使用之前需要确认变量数据类型的语言
* 动态语言：在运行过程中需要检查数据类型的语言
* 隐式类型转换：在操作中把一种类型转换为另一种的操作
* 弱类型语言：支持隐式类型转换的语言
* 强类型语言：不支持隐式类型转换的语言

我们的js就是一种【动态弱类型语言】

JS的数据类型有8种：

![](https://static001.geekbang.org/resource/image/85/15/85b87602eac65356c9171bbd023f5715.png?wh=1142*648)

此外还要注意三点：
* 使用typeof检测 Null 时，会返回 Object，是个 bug
* Object类型比较特殊，它是又以上7中类型组成的包含key-value对的数据类型
* 前7中称为原始类型（基本类型），最后一个对象成为引用类型

在js的执行过程中，主要有三种类型的内存空间：代码空间、栈空间、堆空间，后续讲解代码空间
我们原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的

为什么要这样呢？
js引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间太大的话，所有数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而影响整个程序的执行效率。堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。

对象保存在栈内存中的内容其实是一个引用地址，这个地址对应的是堆内存中具体的内容。

接下来我们理解一下闭包的内存模型：
第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。




## 垃圾回收

算法一：引用计数（堆内存中的每一个对象都有一个属性叫做retainCount，默认为0，当别的地方引用一次该对象，该数字就加一，当对象的这个属性值为0时，垃圾回收器就知道可能没有地方使用它了，这时就会回收改空间。存在一个很大的弊端：循环引用，比如两个对象互相引用对方，如果不=null，这两个对象就会一直在内存中了，造成内存泄漏）

算法二：标记清除（堆内存中有一个根对象，是一个树结构，如果从根对象出发一直找，应该就会找到所有被使用的对象，如果有的对象没有被包含在树中，就说该对象是不可达的，就会销毁掉，这时，即使两个对象互相引用，但是是不可达的，也会销毁掉，很好的解决了循环引用问题）



## 编译器和解释器：V8是如何执行一段JavaScript代码的？

前端工具和框架的自身更新速度非常快，而且还不断有新的出现。要想追赶上前端工具和框架的更新速度，你就需要抓住那些本质的知识，然后才能更加轻松地理解这些上层应用。比如我们接下来要介绍的 V8 执行机制，能帮助你从底层了解 JavaScript，也能帮助你深入理解语言转换器 Babel、语法检查工具 ESLint、前端框架 Vue 和 React 的一些底层实现机制。因此，了解 V8 的编译流程能让你对语言以及相关工具有更加充分的认识。

先理解一下相关概念：
编译器Compiler：
解释器Interpreter：
抽象语法树AST：
字节码ByteCode：
即时编译器JIT：

编译器和解释器的存在原因：机器不能识别我们写的代码，在执行程序之前，需要把我们所写的代码“翻译”成机器能读懂的机器语言。

按照语言的执行流程，可以把语言划分为编译型语言和解释型语言：

* 编译型语言：在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言。

* 解释型语言：每次运行时都需要通过解释器对程序进行动态解释和执行，如python、js语言

编译器和解释器是如何“翻译”代码的呢？
![](https://static001.geekbang.org/resource/image/4e/81/4e196603ecb78188e99e963e251b9781.png?wh=1142*510)

那 V8 是如何执行一段 js 代码的呢？
![](https://static001.geekbang.org/resource/image/1a/ae/1af282bdc4036096c03074da53eb84ae.png?wh=1142*522)
我们来具体文字分析一下

1. 生成抽象语法树（AST）和执行上下文
什么是AST？
高级语言是开发者可以理解的语言，但是让编译器或者解释器来理解就非常困难了。对于编译器或者解释器来说，它们可以理解的就是 AST 了。

AST长什么样子？
AST的结构和代码的结构非常相似，其实你也可以把AST看成代码的结构化的表示，编译器或者解释器后续的工作都需要依赖于 AST，而不是源代码。

AST的用途？
AST 是非常重要的一种数据结构，在很多项目中有着广泛的应用。其中最著名的一个项目是 Babel。Babel 是一个被广泛使用的代码转码器，可以将 ES6 代码转为 ES5 代码，这意味着你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持 ES6。Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。
除了 Babel 外，还有 ESLint 也使用 AST。ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。

生成 AST 需要经过两个阶段？
词法分析：其作用是将一行行的源码拆解成一个个token。所谓token，指的是语法上不可能再分的、最小的单个字符或字符串。
语法分析：其作用是将上一步生成的token数据，根据语法规则转为AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。

有了 AST 后，那接下来 V8 就会生成该段代码的执行上下文。

2. 生成字节码
有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。

为什么要字节码？
其实一开始V8并没有字节码，而是直接将AST转换为机器码，由于执行机器码的效率是非常高效的，所以这种方式在发布后的一段时间内运行效果是非常好的。但是随着Chrome在手机上的广泛普及，特别是运行在512M内存的手机上，内存占用问题也暴露出来了，因为V8需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器，最终花了将进四年的时间，实现了现在的这套架构。

什么是字节码？
字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。

我们看一下对比
![](https://static001.geekbang.org/resource/image/87/ff/87d1ab147d1dc4b78488e2443d58a3ff.png?wh=1142*314)
从图中可以看出，机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。


3. 执行代码
生成字节码之后，接下来就要进入执行阶段了。

通常，如果有一段第一次执行的字节码，解释器Ignition会逐条解释执行。到了这里，相信你已经发现了，解释器Ignition除了负责生成字节码之外，它还有另外一个作用，就是解释执行字节码。在Ignition执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器TurboFan就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。
V8的解释器和编译器的取名也很有意思。解释器Ignition是点火器的意思，编译器TurboFan是涡轮增压的意思，寓意着代码启动时通过点火器慢慢发动，一旦启动，涡轮增压介入，其执行效率随着执行时间越来越高效率，因为热点代码都被编译器TurboFan转换了机器码，直接执行机器码就省去了字节码“翻译”为机器码的过程。
其实字节码配合解释器和编译器是最近一段时间很火的技术，比如Java和Python的虚拟机也都是基于这种技术实现的，我们把这种技术称为即时编译（JIT）。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。
对于JavaScript工作引擎，除了 V8 使用了“字节码 +JIT”技术之外，苹果的SquirrelFish Extreme 和Mozilla的SpiderMonkey也都使用了该技术。这么多语言的工作引擎都使用了“字节码 +JIT”技术，因此理解 JIT 这套工作机制还是很有必要的。你可以结合下图看看 JIT的工作过程：
![](https://static001.geekbang.org/resource/image/66/8a/662413313149f66fe0880113cb6ab98a.png?wh=766*912)

javascript的性能优化：
到这里相信你现在已经了解V8是如何执行一段JavaScript代码的了。在过去几年中，JavaScript的性能得到了大幅提升，这得益于 V8 团队对解释器和编译器的不断改进和优化。
虽然在V8诞生之初，也出现过一系列针对V8而专门优化JavaScript性能的方案，比如隐藏类、内联缓存等概念都是那时候提出来的。不过随着V8的架构调整，你越来越不需要这些微优化策略了，相反，对于优化JavaScript执行效率，你应该将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容：

* 提升单次脚本的执行速度，避免JavaScript的长任务霸占主线程，这样可以使得页面快速响应交互；
* 避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；
* 减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。





