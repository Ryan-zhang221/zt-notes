## 变量提升 & JS执行流程



js代码中会有以下问题：

* 在执行过程中，若使用了未声明的变量，那么JS执行会报错
* 在一个变量定义之前使用它，不会出错，但是该变量的值为 undefined 而不是定义时的值
* 在函数定义之前使用它，不会出错，且函数能正确执行



以上的问题要解释，就要明白一个概念：变量提升

在此之前要理解 声明`var myname` 和 赋值`myname='ryan'` 操作。

变量提升定义：是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。



JavaScript代码的执行流程如下图

![](https://static001.geekbang.org/resource/image/64/1e/649c6e3b5509ffd40e13ce9c91b3d91e.png?wh=1142*203)

一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译，编译完成之后，才会进入执行阶段。

我们刚才的变量提升行为是在编译阶段发生的，我们的变量都在编译阶段被 JS 引擎放入内存中。



我们再细化 JS 的执行流程:

![](https://static001.geekbang.org/resource/image/06/13/0655d18ec347a95dfbf843969a921a13.png?wh=1142*634)

一段代码经过编译后，会生成两部分内容：`执行上下文` 和 `可执行代码`。

执行上下文：执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。



执行上下文中的变量环境对象是如何生成的？

* js引擎对于变量声明，会在变量环境对象中创建一个重名属性，并用 undefined 初始化。
* 对于函数声明，会把函数定义存储到堆内存中，对应一个内存地址。然后同样在变量环境对象中创建一个重名属性，用这个内存地址初始化。



有了变量环境对象，接下来 JS 引擎会把声明以外的代码编译为`字节码`



有了 执行上下文 和 可执行代码，这下就到了`执行阶段`。

按照顺序一行一行执行，变量环境对象中的属性如果被改了，就用新值，如果没有被改，就用默认的值。



如果编译阶段，存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个。因为被覆盖了。







## 调用栈：why js stackoverflow?



在写js代码是有时会遇到：Maximum call stack size exceeded 报错

为什么出现这个问题呢？

这就涉及到了 `调用栈` ：指用来管理函数调用关系的一种数据结构。



在学习之前要了解以下两个概念：

* 函数调用：函数名称跟着一对小括号

  ```js
  var a = 2;
  function add() {
    var b = 10;
    return a + b
  }
  
  add()
  ```

  ![](https://static001.geekbang.org/resource/image/53/ca/537efd9e96771dc50737117e615533ca.png?wh=1142*558)

  就这样，当执行到 add 函数的时候，我们就有了两个执行上下文了——全局执行上下文和 add 函数的执行上下文。也就是说执行 js 时，可能会存在多个执行上下文。那么 js 是如果管理这些上下文的呢？

  即答：通过一种栈的数据结构管理

  

* 栈结构

  理解为摞起来的盘子，后进先出



我们写连续嵌套的代码时，首先调用栈中有一个全局执行上下文，用到了哪个函数，就把该函数执行上下文压入到栈顶，后续如果还有继续压，栈顶的函数执行完毕就会弹出。当代码执行完毕，此时调用栈中就只剩下全局执行上下文了。

总结：调用栈是 js 引擎追踪函数执行的一个机制。当一次又多个函数被调用时，通过调用栈就能追踪到哪个函数正在被执行以及各函数之间的调用关系。



开发中可打断点，在 call stack 中查看调用栈



调用栈是有大小的，当入栈的执行上下文超过一定数目，js引擎就会报错，这种错误就叫做 `栈溢出`

特别是我们写递归代码时，很容易出现这个情况，所以要写终止条件！







## 块级作用域：var的缺陷和let、const的引入



正是由于js存在变量提升这种特性，从而导致了很多与直觉不符的代码，这也是 js 一个重要的设计缺陷。

let const 的引入就是为了避开这个缺陷而生的!



问题一：为什么 js 中存在变量提升这个特性，其他语言似乎没有呢？

我们要从作用域说起，`作用域`是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

* 全局作用域：其中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
* 函数作用域：在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。



在 es6 之前，js 只支持这两种作用域。

而`块级作用域`是指：用一对大括号包裹的一段代码，比如函数、判断语句、循环语句、甚至一个单独的 {} 都是一个块级作用域。简单来讲，如果一种语言支持块级作用域，那么其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。



在 es6 之前，除了函数，大括号中使用 var 声明的变量在大括号外也可以访问到，这就会造成很多奇怪的情况。（这个叫js中的变量提升，注意和之前的变量提升进行区分）



所以 let 和 const 的出现让 js 有了块级作用域



具体 let 是如何实现的呢，通过一张图来理解

![](https://static001.geekbang.org/resource/image/06/08/06c06a756632acb12aa97b3be57bb908.png?wh=1142*557)



总结：块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了。





## 作用域链和闭包







## this

