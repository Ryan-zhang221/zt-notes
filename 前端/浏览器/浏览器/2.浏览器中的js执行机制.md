## 变量提升 & JS执行流程



js代码中会有以下问题：

* 在执行过程中，若使用了未声明的变量，那么JS执行会报错
* 在一个变量定义之前使用它，不会出错，但是该变量的值为 undefined 而不是定义时的值
* 在函数定义之前使用它，不会出错，且函数能正确执行



以上的问题要解释，就要明白一个概念：变量提升

在此之前要理解 声明`var myname` 和 赋值`myname='ryan'` 操作。

变量提升定义：是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。



JavaScript代码的执行流程如下图

![](https://static001.geekbang.org/resource/image/64/1e/649c6e3b5509ffd40e13ce9c91b3d91e.png?wh=1142*203)

一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译，编译完成之后，才会进入执行阶段。

我们刚才的变量提升行为是在编译阶段发生的，我们的变量都在编译阶段被 JS 引擎放入内存中。



我们再细化 JS 的执行流程:

![](https://static001.geekbang.org/resource/image/06/13/0655d18ec347a95dfbf843969a921a13.png?wh=1142*634)

一段代码经过编译后，会生成两部分内容：`执行上下文` 和 `可执行代码`。

执行上下文：执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。



执行上下文中的变量环境对象是如何生成的？

* js引擎对于变量声明，会在变量环境对象中创建一个重名属性，并用 undefined 初始化。
* 对于函数声明，会把函数定义存储到堆内存中，对应一个内存地址。然后同样在变量环境对象中创建一个重名属性，用这个内存地址初始化。



有了变量环境对象，接下来 JS 引擎会把声明以外的代码编译为`字节码`



有了 执行上下文 和 可执行代码，这下就到了`执行阶段`。

按照顺序一行一行执行，变量环境对象中的属性如果被改了，就用新值，如果没有被改，就用默认的值。



如果编译阶段，存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个。因为被覆盖了。







## 调用栈：why js stackoverflow?



在写js代码是有时会遇到：Maximum call stack size exceeded 报错

为什么出现这个问题呢？

这就涉及到了 `调用栈` ：指用来管理函数调用关系的一种数据结构。



在学习之前要了解以下两个概念：

* 函数调用：函数名称跟着一对小括号

  ```js
  var a = 2;
  function add() {
    var b = 10;
    return a + b
  }
  
  add()
  ```

  ![](https://static001.geekbang.org/resource/image/53/ca/537efd9e96771dc50737117e615533ca.png?wh=1142*558)

  就这样，当执行到 add 函数的时候，我们就有了两个执行上下文了——全局执行上下文和 add 函数的执行上下文。也就是说执行 js 时，可能会存在多个执行上下文。那么 js 是如果管理这些上下文的呢？

  即答：通过一种栈的数据结构管理

  

* 栈结构

  理解为摞起来的盘子，后进先出



我们写连续嵌套的代码时，首先调用栈中有一个全局执行上下文，用到了哪个函数，就把该函数执行上下文压入到栈顶，后续如果还有继续压，栈顶的函数执行完毕就会弹出。当代码执行完毕，此时调用栈中就只剩下全局执行上下文了。

总结：调用栈是 js 引擎追踪函数执行的一个机制。当一次又多个函数被调用时，通过调用栈就能追踪到哪个函数正在被执行以及各函数之间的调用关系。



开发中可打断点，在 call stack 中查看调用栈



调用栈是有大小的，当入栈的执行上下文超过一定数目，js引擎就会报错，这种错误就叫做 `栈溢出`

特别是我们写递归代码时，很容易出现这个情况，所以要写终止条件！







## 块级作用域：var的缺陷和let、const的引入



正是由于js存在变量提升这种特性，从而导致了很多与直觉不符的代码，这也是 js 一个重要的设计缺陷。

let const 的引入就是为了避开这个缺陷而生的!



问题一：为什么 js 中存在变量提升这个特性，其他语言似乎没有呢？

我们要从作用域说起，`作用域`是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

* 全局作用域：其中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
* 函数作用域：在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。



在 es6 之前，js 只支持这两种作用域。

而`块级作用域`是指：用一对大括号包裹的一段代码，比如函数、判断语句、循环语句、甚至一个单独的 {} 都是一个块级作用域。简单来讲，如果一种语言支持块级作用域，那么其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。



在 es6 之前，除了函数，大括号中使用 var 声明的变量在大括号外也可以访问到，这就会造成很多奇怪的情况。（这个叫js中的变量提升，注意和之前的变量提升进行区分）



所以 let 和 const 的出现让 js 有了块级作用域



具体 let 是如何实现的呢，通过一张图来理解

![](https://static001.geekbang.org/resource/image/06/08/06c06a756632acb12aa97b3be57bb908.png?wh=1142*557)



总结：块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了。





## 作用域链和闭包

词法作用域：指作用域是由代码中函数声明的位置决定的，就是说函数声明在哪里，它的作用域链就固定了。往深了说，词法作用域是代码编译阶段就决定好了的，和函数怎么调用没有关系。

作用域链就是变量的查找链条。

闭包：内部函数使用了外部函数中的变量，尽管外层函数已经执行完毕，但是这两个变量还有引用，垃圾回收机制不会回收，这两个变量就像内层函数的专属背包，所以就叫内层函数的闭包。

闭包如何回收？
闭包使用不正确会造成内存泄露，所以我们要正确回收。
我们使用闭包的时候注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。







## this

js语言的作用域链是由词法作用域决定的，而词法作用域是由代码结构来==确定==的。

this的由来：我们在日常工作中，在对象内部的方法中使用对象内部的属性是一个非常普遍的需求，但是 JS 的作用域机制并不支持这一点，基于这个需求，js 又搞出来了一套 this 机制。

注意：作用域链 和 this 是两套不同的系统，它们之间基本没太多联系。

this 是和执行上下文绑定的，每个执行上下文中都有一个 this，主要this有两种：
* 全局执行上下文中的this：window对象
* 函数中的this：默认也是window，但是有三种办法来改这个this
	* 通过 call/bind/apply 来手动改变
	* 通过对象调用方法设置 `obj.foo()` 此时foo函数中的this就是 obj 对象
	* 构造函数中设置（new操作符的作用）构造函数中的this就是新对象本身

this有很多问题：
1.嵌套函数中的this不会从外层函数中继承
我们知道了this没有作用域的限制，这点和变量不一样，所以嵌套函数不会从调用它的函数中继承this，这样会造成很多不符合直觉的代码，解决这个问题的两种思路就是：
* 把this保存为一个self变量，再利用变量的作用域机制传递给嵌套函数
第二种是继续使用this，但是把嵌套函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以它会继承调用函数中的this

* 普通函数中的this默认指向全局对象window
  这个设计也是一种缺陷，我们实际工作中，并不希望函数执行上下文中的this默认指向全局对象，因为这样会打破数据的边界。如果要让函数执行上下文中的this指向某个对象，最好的方式是通过 call 方法来显示调用。
  这个问题可以通过js的严格模式来解决
