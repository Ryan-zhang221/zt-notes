## 1、vue组件之间的通信方式

> vue是组件化开发框架，所以对于vue应用来说组件间的数据通信非常重要。此题主要考查大家vue基本功，对于vue基础api运用熟练度。另外一些边界知识如provide/inject/$attrs则提现了面试者的知识广度。
>
> 
>
> 思路：
>
> 1、总述知道的所有方式
>
> 2、按照组件阐述使用场景

父子组件：`props $emit $parent ref $attrs`

兄弟组件：`$parent $root eventbus vuex`

跨层级关系：`eventbus vuex provide+inject`





## 2、v-if 和 v-for 哪个优先级更高？

>此题考查常识，文档中曾有详细说明v2|v3；也是一个很好的实践题目，项目中经常会遇到，能够看出面试者api熟悉程度和应用能力。
>
>
>
>思路：
>
>1、先给出结论
>
>2、为什么是这样，说出细节
>
>3、哪些场景可能导致我们这样做，该怎么处理
>
>4、总结，拔高

1. 实践中**不应该把v-for和v-if放一起**

2. 在**vue2中**，**v-for的优先级是高于v-if**，把它们放在一起，输出的渲染函数中可以看出会先执行循环再判断条件，哪怕我们只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表，这会比较浪费；另外需要注意的是在**vue3中则完全相反，v-if的优先级高于v-for**，所以v-if执行时，它调用的变量还不存在，就会导致异常

3. 通常有两种情况下导致我们这样做：

4. * 为了**过滤列表中的项目** (比如 `v-for="user in users" v-if="user.isActive"`)。此时定义一个计算属性 (比如 `activeUsers`)，让其返回过滤后的列表即可（比如`users.filter(u=>u.isActive)`）。
   * 为了**避免渲染本应该被隐藏的列表** (比如 `v-for="user in users" v-if="shouldShowUsers"`)。此时把 `v-if` 移动至容器元素上 (比如 `ul`、`ol`)或者外面包一层`template`即可。

5. 文档中明确指出**永远不要把 `v-if` 和 `v-for` 同时用在同一个元素上**，显然这是一个重要的注意事项。

6. 源码里面关于代码生成的部分，能够清晰的看到是先处理v-if还是v-for，顺序上vue2和vue3正好相反，因此产生了一些症状的不同，但是不管怎样都是不能把它们写在一起的。



## 3、简述 Vue 的生命周期以及每个阶段做的事

>必问题目，考查vue基础知识。
>
>思路：
>
>1. 给出概念
>2. 列举生命周期各阶段
>3. 阐述整体流程
>4. 结合实践
>5. 扩展：vue3变化

1、每个Vue组件实例被创建后都会经过一系列初始化步骤，比如，它需要数据观测，模板编译，挂载实例到dom上，以及数据变化时更新dom。这个过程中会运行叫做生命周期钩子的函数，以便用户在特定阶段有机会添加他们自己的代码。



2、每个Vue组件实例被创建后都会经过一系列初始化步骤，比如，它需要数据观测，模板编译，挂载实例到dom上，以及数据变化时更新dom。这个过程中会运行叫做生命周期钩子的函数，以便用户在特定阶段有机会添加他们自己的代码。

| 生命周期v2    | 生命周期v3          | 描述                                     |
| :------------ | :------------------ | :--------------------------------------- |
| beforeCreate  | beforeCreate        | 组件实例被创建之初                       |
| created       | created             | 组件实例已经完全创建                     |
| beforeMount   | beforeMount         | 组件挂载之前                             |
| mounted       | mounted             | 组件挂载到实例上去之后                   |
| beforeUpdate  | beforeUpdate        | 组件数据发生变化，更新之前               |
| updated       | updated             | 数据数据更新之后                         |
| beforeDestroy | **beforeUnmount**   | 组件实例销毁之前                         |
| destroyed     | **unmounted**       | 组件实例销毁之后                         |
| activated     | activated           | keep-alive 缓存的组件激活时              |
| deactivated   | deactivated         | keep-alive 缓存的组件停用时调用          |
| errorCaptured | errorCaptured       | 捕获一个来自子孙组件的错误时被调用       |
| -             | **renderTracked**   | 调试钩子，响应式依赖被收集时调用         |
| -             | **renderTriggered** | 调试钩子，响应式依赖被触发时调用         |
| -             | **serverPrefetch**  | ssr only，组件实例在服务器上被渲染前调用 |

3、`Vue`生命周期流程图：

4、结合实践：

* **beforeCreate**：通常用于插件开发中执行一些初始化任务

  **created**：组件初始化完毕，可以访问各种数据，获取接口数据等

  **mounted**：dom已创建，可用于获取访问数据和dom元素；访问子组件等。

  **beforeUpdate**：此时`view`层还未更新，可用于获取更新前各种状态

  **updated**：完成`view`层的更新，更新后，所有状态已是最新

  **beforeunmount**：实例被销毁前调用，可用于一些定时器或订阅的取消

  **unmounted**：销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器





## 4、能说一说双向绑定使用和原理吗？

> 双向绑定是`vue`的特色之一，开发中必然会用到的知识点，然而此题还问了实现原理，升级为深度考查。
>
> 思路：
>
> 1. 给出双绑定义
> 2. 双绑带来的好处
> 3. 在哪使用双绑
> 4. 使用方式、使用细节、vue3变化
> 5. 原理实现描述

1. vue中双向绑定是一个指令`v-model`，可以绑定一个响应式数据到视图，同时视图中变化能改变该值。
2. `v-model`是语法糖，默认情况下相当于`:value`和`@input`。使用`v-model`可以减少大量繁琐的事件处理代码，提高开发效率。
3. 通常在表单项上使用`v-model`，还可以在自定义组件上使用，表示某个值的输入和输出控制。
4. 通过`<input v-model="xxx">`的方式将xxx的值绑定到表单元素value上；对于checkbox，可以使用`true-value`和false-value指定特殊的值，对于radio可以使用value指定特殊的值；对于select可以通过options元素的value设置特殊的值；还可以结合.lazy,.number,.trim对v-mode的行为做进一步限定；`v-model`用在自定义组件上时又会有很大不同，vue3中它类似于`sync`修饰符，最终展开的结果是modelValue属性和update:modelValue事件；vue3中我们甚至可以用参数形式指定多个不同的绑定，例如v-model:foo和v-model:bar，非常强大！
5. `v-model`是一个指令，它的神奇魔法实际上是vue的编译器完成的。我做过测试，包含`v-model`的模板，转换为渲染函数之后，实际上还是是value属性的绑定以及input事件监听，事件回调函数中会做相应变量更新操作。编译器根据表单元素的不同会展开不同的DOM属性和事件对，比如text类型的input和textarea会展开为value和input事件；checkbox和radio类型的input会展开为checked和change事件；select用value作为属性，用change作为事件。



## 5、Vue中如何扩展一个组件

>此题属于实践题，考察大家对vue常用api使用熟练度，答题时不仅要列出这些解决方案，同时最好说出他们异同。
>
>
>
>思路：
>
>1. 按照逻辑扩展和内容扩展来列举，
>
>2. * 逻辑扩展有：mixins、extends、composition api；
>   * 内容扩展有slots；
>
>3. 分别说出他们使用方法、场景差异和问题。
>
>4. 作为扩展，还可以说说vue3中新引入的composition api带来的变化

。。。



## 6、子组件可以直接改变父组件的数据么，说明原因

> 这是一个实践知识点，组件化开发过程中有个**单项数据流原则**，不在子组件中修改父组件是个常识问题。
>
> 思路：
>
> 1. 讲讲单项数据流原则，表明为何不能这么做
> 2. 举几个常见场景的例子说说解决方案
> 3. 结合实践讲讲如果需要修改父组件状态应该如何做





































