## 1、vue组件之间的通信方式

> vue是组件化开发框架，所以对于vue应用来说组件间的数据通信非常重要。此题主要考查大家vue基本功，对于vue基础api运用熟练度。另外一些边界知识如provide/inject/$attrs则提现了面试者的知识广度。
>
> 
>
> 思路：
>
> 1、总述知道的所有方式
>
> 2、按照组件阐述使用场景

父子组件：`props $emit $parent ref $attrs`

兄弟组件：`$parent $root eventbus vuex`

跨层级关系：`eventbus vuex provide+inject`





## 2、v-if 和 v-for 哪个优先级更高？

>此题考查常识，文档中曾有详细说明v2|v3；也是一个很好的实践题目，项目中经常会遇到，能够看出面试者api熟悉程度和应用能力。
>
>
>
>思路：
>
>1、先给出结论
>
>2、为什么是这样，说出细节
>
>3、哪些场景可能导致我们这样做，该怎么处理
>
>4、总结，拔高

1. 实践中**不应该把v-for和v-if放一起**

2. 在**vue2中**，**v-for的优先级是高于v-if**，把它们放在一起，输出的渲染函数中可以看出会先执行循环再判断条件，哪怕我们只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表，这会比较浪费；另外需要注意的是在**vue3中则完全相反，v-if的优先级高于v-for**，所以v-if执行时，它调用的变量还不存在，就会导致异常

3. 通常有两种情况下导致我们这样做：

4. * 为了**过滤列表中的项目** (比如 `v-for="user in users" v-if="user.isActive"`)。此时定义一个计算属性 (比如 `activeUsers`)，让其返回过滤后的列表即可（比如`users.filter(u=>u.isActive)`）。
   * 为了**避免渲染本应该被隐藏的列表** (比如 `v-for="user in users" v-if="shouldShowUsers"`)。此时把 `v-if` 移动至容器元素上 (比如 `ul`、`ol`)或者外面包一层`template`即可。

5. 文档中明确指出**永远不要把 `v-if` 和 `v-for` 同时用在同一个元素上**，显然这是一个重要的注意事项。

6. 源码里面关于代码生成的部分，能够清晰的看到是先处理v-if还是v-for，顺序上vue2和vue3正好相反，因此产生了一些症状的不同，但是不管怎样都是不能把它们写在一起的。



## 3、简述 Vue 的生命周期以及每个阶段做的事

>必问题目，考查vue基础知识。
>
>思路：
>
>1. 给出概念
>2. 列举生命周期各阶段
>3. 阐述整体流程
>4. 结合实践
>5. 扩展：vue3变化

1、每个Vue组件实例被创建后都会经过一系列初始化步骤，比如，它需要数据观测，模板编译，挂载实例到dom上，以及数据变化时更新dom。这个过程中会运行叫做生命周期钩子的函数，以便用户在特定阶段有机会添加他们自己的代码。



2、每个Vue组件实例被创建后都会经过一系列初始化步骤，比如，它需要数据观测，模板编译，挂载实例到dom上，以及数据变化时更新dom。这个过程中会运行叫做生命周期钩子的函数，以便用户在特定阶段有机会添加他们自己的代码。

| 生命周期v2    | 生命周期v3          | 描述                                     |
| :------------ | :------------------ | :--------------------------------------- |
| beforeCreate  | beforeCreate        | 组件实例被创建之初                       |
| created       | created             | 组件实例已经完全创建                     |
| beforeMount   | beforeMount         | 组件挂载之前                             |
| mounted       | mounted             | 组件挂载到实例上去之后                   |
| beforeUpdate  | beforeUpdate        | 组件数据发生变化，更新之前               |
| updated       | updated             | 数据数据更新之后                         |
| beforeDestroy | **beforeUnmount**   | 组件实例销毁之前                         |
| destroyed     | **unmounted**       | 组件实例销毁之后                         |
| activated     | activated           | keep-alive 缓存的组件激活时              |
| deactivated   | deactivated         | keep-alive 缓存的组件停用时调用          |
| errorCaptured | errorCaptured       | 捕获一个来自子孙组件的错误时被调用       |
| -             | **renderTracked**   | 调试钩子，响应式依赖被收集时调用         |
| -             | **renderTriggered** | 调试钩子，响应式依赖被触发时调用         |
| -             | **serverPrefetch**  | ssr only，组件实例在服务器上被渲染前调用 |

3、`Vue`生命周期流程图：

4、结合实践：

* **beforeCreate**：通常用于插件开发中执行一些初始化任务

  **created**：组件初始化完毕，可以访问各种数据，获取接口数据等

  **mounted**：dom已创建，可用于获取访问数据和dom元素；访问子组件等。

  **beforeUpdate**：此时`view`层还未更新，可用于获取更新前各种状态

  **updated**：完成`view`层的更新，更新后，所有状态已是最新

  **beforeunmount**：实例被销毁前调用，可用于一些定时器或订阅的取消

  **unmounted**：销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器





## 4、能说一说双向绑定使用和原理吗？

> 双向绑定是`vue`的特色之一，开发中必然会用到的知识点，然而此题还问了实现原理，升级为深度考查。
>
> 思路：
>
> 1. 给出双绑定义
> 2. 双绑带来的好处
> 3. 在哪使用双绑
> 4. 使用方式、使用细节、vue3变化
> 5. 原理实现描述

1. vue中双向绑定是一个指令`v-model`，可以绑定一个响应式数据到视图，同时视图中变化能改变该值。
2. `v-model`是语法糖，默认情况下相当于`:value`和`@input`。使用`v-model`可以减少大量繁琐的事件处理代码，提高开发效率。
3. 通常在表单项上使用`v-model`，还可以在自定义组件上使用，表示某个值的输入和输出控制。
4. 通过`<input v-model="xxx">`的方式将xxx的值绑定到表单元素value上；对于checkbox，可以使用`true-value`和false-value指定特殊的值，对于radio可以使用value指定特殊的值；对于select可以通过options元素的value设置特殊的值；还可以结合.lazy,.number,.trim对v-mode的行为做进一步限定；`v-model`用在自定义组件上时又会有很大不同，vue3中它类似于`sync`修饰符，最终展开的结果是modelValue属性和update:modelValue事件；vue3中我们甚至可以用参数形式指定多个不同的绑定，例如v-model:foo和v-model:bar，非常强大！
5. `v-model`是一个指令，它的神奇魔法实际上是vue的编译器完成的。我做过测试，包含`v-model`的模板，转换为渲染函数之后，实际上还是是value属性的绑定以及input事件监听，事件回调函数中会做相应变量更新操作。编译器根据表单元素的不同会展开不同的DOM属性和事件对，比如text类型的input和textarea会展开为value和input事件；checkbox和radio类型的input会展开为checked和change事件；select用value作为属性，用change作为事件。



## 5、Vue中如何扩展一个组件

>此题属于实践题，考察大家对vue常用api使用熟练度，答题时不仅要列出这些解决方案，同时最好说出他们异同。
>
>
>
>思路：
>
>1. 按照逻辑扩展和内容扩展来列举，
>
>2. * 逻辑扩展有：mixins、extends、composition api；
>   * 内容扩展有slots；
>
>3. 分别说出他们使用方法、场景差异和问题。
>
>4. 作为扩展，还可以说说vue3中新引入的composition api带来的变化

。。。



## 6、子组件可以直接改变父组件的数据么，说明原因

> 这是一个实践知识点，组件化开发过程中有个**单项数据流原则**，不在子组件中修改父组件是个常识问题。
>
> 思路：
>
> 1. 讲讲单项数据流原则，表明为何不能这么做
> 2. 举几个常见场景的例子说说解决方案
> 3. 结合实践讲讲如果需要修改父组件状态应该如何做

1. 所有 prop 都使得父子之间形成了一个单向下行绑定，父级 prop 的更新会向下流动到子组件中，但是反过来就不行。这样会防止从子组件意外变更父组件的状态，从而导致应用的数据流向难以理解。父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值，这意味着不应该在子组件内部改变 prop，如果这样做了，Vue 会在浏览器中发出警告，props是只读的！
2. 实际开发中有两个场景会想要修改一个属性：
   1. prop 用来传递一个初始值，这个子组件接下来希望将其作为一个本地的 props 来使用。这种情况下，最好定义一个本地 data = prop
   2. prop 以一种原始的值传入且需要进行转换。这种情况下，最好使用这个 prop 的值来定义一个计算属性
3. 实践中如果确实想要改变父组件属性应该 emit 一个事件让父组件去做这个变更。注意，虽然我们不能直接修改一个传入的对象或者数组类型 prop，但是我们还是能够直接修改内嵌的对象或属性



## 7、Vue要做权限管理要怎么做？控制到按钮级别的权限怎么做？

github：https://github.com/PanJiaChen/vue-element-admin.git

>综合实践题目，实际开发中经常需要面临权限管理的需求，考察实际应用能力
>
>权限管理的需求一般是两个，页面权限和按钮权限，从这两个方面论述
>
>思路：
>
>1. 权限管理需求分析，页面和按钮权限
>2. 权限管理的实现方案，分后端方案和前端方案阐述
>3. 说说各自的优缺点

1. 权限管理一般需求是页面权限和按钮权限的管理
2. 具体实现方案分为前端方案和后端方案：
   1. 前端方案会把所有的路由信息在前端配置，通过路由守卫要求用户登录，用户登录后根据角色过滤出路由表，比如我会配置一个 asyncRoutes 数组，需要认证的页面在其路由的 meta 中添加一个 roles 字段，等获取用户角色之后取两者的交集，若结果不为空则说明可以访问，此过滤过程结束，剩下的路由就是该用户能访问的页面，最后通过 router.addRoutes(accessRoutes)的方式动态添加路由即可。
   2. 后端方案会把所有的路由信息存在数据库中，用户登录的时候根据其角色查询得到其能访问的所有页面路由信息返回给前端，前端通过 addRoutes 动态添加路由信息
   3.  按钮权限的控制通常会实现一个指令，例如 v-permission，将按钮要求角色通过值传给 v-permission 指令，在指令的 mounted 钩子中可以判断当前用户角色和按钮是否存在交集，有则保留按钮，没有则移除按钮
3. 纯前端方案的有点是实现简单，不需要额外权限管理页面，但是维护起来问题比较大，有新的页面和角色需求就要修改前端代码重新打包部署，服务端方案就不存在这个问题，通过专门的角色和权限管理页面，配置页面和按钮权限信息到数据库，应用每次登录时获取的都是最新的路由信息，可谓一劳永逸！



## 8、说一说你对 Vue 响应式的理解

>必问题目
>
>思路：
>
>1. 啥是响应式？
>2. 为什么 Vue 需要响应式？
>3. 它能给我们带来什么好处？
>4. Vue 的响应式是如何实现的？有哪些优缺点？
>5. Vue3 中的响应式的新变化

1. 所谓数据响应式就是能够使数据变化可以被检测并对这种变化做出响应的机制
2. MVVM 框架中要解决的一个核心问题就是连接数据层和视图层，通过数据驱动应用，数据变化，视图更新，要做到这一点就需要对数据做响应式处理，这样一旦数据发生变化就可以立即做出更新处理
3. 以 Vue 为例，通过数据响应式加上虚拟 DOM 和 Patch 算法，开发人员只需要操作数据，关心业务，完全不用接触繁琐的 DOM 操作，从而大大提升开发效率，降低开发难度。
4. Vue2 中的数据响应式会根据数据类型的不同做不同的处理，如果是对象，则采用 `Object.defineProperty()` 的方式定义数据拦截，但数据被访问或发生变化时，我们感知并作出响应，如果是数组则通过覆盖数据对象原型的7个变更方法，使得这些方法可以额外做更新通知，从而做出响应。这种机制很好的解决了数据响应化的问题，但在实际使用中也存在一些缺点，比如初始化时的递归遍历会造成性能损失，新增或删除属性时需要用户使用 Vue.set/delete 这样特殊的 api 才能生效，对于 ES6 中的 Map、Set 等数据结构不支持等问题
5. 为了解决这些问题，Vue3 重新编写了这一部分的实现，利用 ES6 的 Proxy 代理要响应化的数据，它有很多好处，编程体验一致，不需要使用特殊 api，初始化性能消耗和内存消耗都得到了很大改善，另外由于响应化的实现代码抽取为独立的 reactivity 包，使得我们可以更灵活使用它，第三方扩展开发起来更加灵活。



## 9、说一说你对虚拟 DOM 的理解

> 现有框架几乎都引入了虚拟 DOM 来对真实 DOM 进行抽象，也就是现在大家所熟知的 VNode 和 VDOM，那么为什么需要引入虚拟 DOM 呢？围绕这个疑问来解答即可！
>
> 思路：
>
> 1. vdom是什么？
> 2. 引入vdom 的好处
> 3. vdom 如何生成，又如果变成 dom？
> 4. 后续 diff 中的作用

1. 































