## 定位有哪几种？分别简述其特点



static：

元素默认的位置，默认的定位方式就是static，这种定位方式只能用[margin](https://so.csdn.net/so/search?q=margin&spm=1001.2101.3001.7020)来改变位置，对left、top、z-index等设置值无效，这种定位不脱离文档流



relative：

基于元素自身变化之前的位置进行定位，可以通过设置left、top等值，使得指定元素相对其正常的位置进行偏移，这种定位不脱离文档流



absolute：

绝对定位是根据设置有position属性,并且值不为static的父级进行定位;如果都没有已定位的祖先元素,则是基于浏览器窗口进行定位. margin的自动(auto)会失效，该方式脱离文档流



fixed：

基于浏览器窗口进行定位,并不会伴随屏幕滚动进行滚动，脱离文档流,不保留原来的位置，会改变元素的特性，父元素设置了固定定位,不用清除浮动的影响



inherit：

这种方式规定该元素继承父元素的position属性值。





## 描述一下网页从开始请求到最终显示的完整过程



延伸问题：

是否了解 tcp/ip 的三次握手，四次挥手

谈谈对 http 和 https 的理解

​	http协议明文传输，不安全，容易造成数据的劫持和篡改，默认 80 端口

​	https 密文传输，安全，不会造成数据的劫持和篡改，默认443端口



常见的加密手段

* 置换（摩斯密码、520-我爱你）
* 移位（将信息按照一定的规律移动后进行展示）



对称加密和非对称加密

对称加密：

​	加密和解密使用的是同一个秘钥（密码本）

​	优点：加密效率高，加密时间短

​	缺点：不利于互联网传播，秘钥管理麻烦，

非对称加密：

​	加密和解密不是同一个密码本，有分公钥和私钥。

​	公钥和私钥通过复杂的数学产生，来自于同一个数，但是公钥无法推导出私钥，私钥无法推导出公钥。

​	如果是公钥加密，必须是对应的私钥解密（又叫做加密）

​	如果是私钥加密（签名），要用对应的公钥解密（验签）（又叫做数字签名）

​	优点：利于互联网传播

​	缺点：加密效率低下，加密时间长

混合加密：对称 + 非对称

​	https就使用这种加密方式

​	https 工作原理：。。。。





## link 和 import 的区别

 

link 是标签引入

import 是 ES6 语法引入





## call() 和 apply() 的区别



都是为了修正 this 的指向

call 和 apply 的传参方式不一样

call 一个个传递

apply 通过数组传递



延伸问题：bind

也可以修正 this 的指向，返回一个修正 this 后的新的函数





## js 深拷贝 和 浅拷贝的区别



深拷贝：创建一个新对象，互相不影响

浅拷贝：只是地址的一个引用，会彼此互相影响





## es6的新特性，简述作用



let

const

解构赋值

箭头函数

Class

es6模块化

symbol set map

async await

...





## vue 声明周期和生命周期函数



beforeCreated

created

beforeMounted

mounted

beforeUpdate

updated

beforeDestory

destoryed



一共11个，去官网查看





## 如何解决跨域问题



什么叫跨域

域名端口不一致，不同域名之间的请求称为跨域

协议+域名+端口中任何一个不一样，就叫做跨域

由于浏览器同源策略，浏览器不允许不同域名之间的互相请求



跨域请求的时候，请求发了，响应也给了，之后当数据响应回来的时候，浏览器会拦截，进行比对，如果请求服务器和当前的域名是相同的，则把数据直接放行，否则丢弃。



解决方案：

cors 设置响应头，告知浏览器哪些域名可以跨域请求

使用同域代理

使用 nginx 做反向代理服务器实现请求，同域代理

使用 jsonp 代替





## 闭包的理解



闭包指的是当函数执行完毕后，返回的信息引用声明时作用域内的信息，函数执行完毕后，内存信息还不能释放。



作用域链

原型链



## 小程序页面有哪些传递数据的方法



query传参

基于 globalData 传递

storage

eventChannel

mobx（vuex）





## 简单描述微信小程序的相关文件类型



wxml

wxss

js

json





## css 清除浮动



overflow：hidden

基于 clear：both





## 解构相关题目



解构需要我们两边的结构一致，约定俗称，对于不需要的内容，一般使用_代替

```JS
const sth = {
  orderId: '12231231',
  address: { city:'hz', street: 'xihu' },
  prices: [10, 20, 30]
}

// 需要的内容：street 和 prices 的第二个元素
let { address: {street}, prices: [_, a] } = sth

console.log(street, sth)
```



## http 状态码知道哪些



200 成功请求

300 （301永久重定向-360bug.com>jd.com，302临时重定向，304资源没有变化，可以使用浏览器缓存）

400 （401没有权限、403服务器设置不允许访问、404页面不存在）

500 （服务器内部错误）





## vue 的两个核心是什么，你是怎么理解他们的



1. 双向数据绑定（数据驱动、响应式）

   数据劫持+发布订阅

2. 组件化

   代码的复用和后期维护方便





## vue中，如何让 css 只在当前组件起作用？



style 标签中加入 scope

scope 的底层原理是什么？

自定义属性

使用第三方组件的时候，如果做穿透

/deep/ 选择器

::v-deep

```
>>>
```







## mvc 和 mvvm 的理解



它们两个都是一种分层开发的思想

mvc最先是后端的一种分层编程思想，代码分为

M：Model 的简写，模型，负责和数据（库）打交道

V：View 的简写，视图，负责数据的收集和展示

C：controller 的简写，控制器，负责业务逻辑的处理，由控制器决定是否需要模型和视图的载入（如果业务需要模型参与，则可以实例化一个 model，如果需要视图参与则进行视图的载入即可）



MVVM 是借鉴后端的 MVC 形成的一种分层开发的编程思想

M：Model 的简写，也叫模型，负责数据的处理，前端的表现形式就是一个 js 字面量对象

 new Vue({el, data})

V：View 的简写，翻译过来叫做 视图，负责数据的展示和收集，前端的表现形式就是 vue 管理的区域，可以使用 vuejs 的语法，例如插值表达式，还有指令 v-for v-text v-html ...

VM：viewMOdel的简写，翻译过来叫做视图模型，负责业务逻辑的实现，表现形式就是我们的 new Vue() 的实例对象，该实例读写充当一个桥梁的角色，通过桥梁连接视图和模型，当模型数据变化后，可以通过桥梁的（数据劫持+发布订阅）实现视图的更新，当视图发生变化（v-model或事件），可以直接通过桥梁响应到模型里面。

vuejs通过mvvm的思想，实现了双向数据绑定，可以做到响应式，底层使用的就是 数据劫持+发布订阅 ，底层使用的 api 就是基于 es5 的 Object.defineProperty 去对模型里面的数据做劫持，然后使用发布订阅模型去更新视图。





## vue 的简单实现









## vue-router 有哪几种导航守卫（导航钩子）



路由前置守卫

Router.beforeEach((to, from, next) => {})

to 代表将要前往的路由的信息

from 代表从哪里来的路由信息

next 是一个放行函数，如果执行之后可以到达 to ，否则可以给 next('/login ')



路由的后置守卫

Router.afterEach((to, from) => {})





## Promise 对象是什么？三种状态是什么？成功时执行的方法，失败时执行的方法



Promise是一个承诺，代表的是对未来的一个许诺，有可能成功，有可能失败

pending

fulfilling

rejected



New Promsie()





## 怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数？



1. 动态路由传参

```js
{
  path: '/login/:id',
  name: 'login',
  component: login
}
```

this.$route.params.id 获取



2. query传参

```js
{
  path: '/detail',
  name: 'detail',
  component: detail
}
```

// 编程式导航，做页面跳转

this.$route.push({

​	path: '/detail',

​	query: { id: 12 }

})

this.$route.query.id 获取







## css 中 px em 各有什么优劣，在表现上有什么区别？



px像素单位

em相对单位：相对于自身的 font-size 大小，如果自身么有，就找夫元素，如果还没有就，则继续向外查找





## get 和 post 的区别



传递参数的方式不一样

传递数据的大小

安全性

文件上传





## JS上传文件的方法



ajax 2.0 的异步文件上传

const newForm = formData()

newForm.append(key, value)





## vue使用 keep-alive 缓存的组件使用哪个钩子函数刷新组件



在做组件切换的时候，组件是新增或者销毁，如果有的时候，我们切换组件时不希望组件销毁，而是希望组件的状态要保持，则我们可以在该组件外面套一个 keep-alive 组件，那这个组件就不会被销毁，那么其他的生命周期函数就会失效，那么这个时候要使用如下的生命周期函数

activated

deactivated





## v-show 和 v-if 的区别



V-show 控制 css 的 display 属性，适用于频繁显示隐藏的场景

v-if 控制 dom 元素的新增或移除，适用于不经常显示隐藏的场景





## let const var 的区别



var 存在的弊端

var 声明的变量可以重复

var 会做预解析



ES6 引入 let 关键字

let 不允许重复声明变量，和 var 同时声明一个变量也是不允许的

let 不会做预解析，在声明之前的部分无法使用该变量，这个区域我们叫做死区

let 是块级作用域



const 声明常量

const 声明的时候必须赋初始值

后期常量的值不能被重新赋值，如果重新赋值会报错





## 使用 Promise 封装一个公共方法



本质上就是使用 promise 封装一个异步方法

```js
const fs = require('fs')

function read() {
  return new Promise((resolve, reject) => {
    fs.readFile(path, 'utf-8', (error, data) => {
      if (error) {
        reject(error)
      } else {
        resolve(data)
      }
    })
  })
}

let path = './data/1.txt'

read(path).then(res => {
  console.log(res)
}).catch(err => {
  console.log(err)
})
```



## vue 里面引用文件的方式有哪些



考察的是 ES6 里面的模块化

```js
import 'npm 包'

import xx from './xx.js'

// 按需导入
import { xxx } from './xxxx.js'
```





## cookie localStorage sessionStorage 的区别和使用场景



考点：客户端存储技术



cookie

* 客户端存储技术

* 服务端和客户端都可以操作 cookie

* cookie 有大小，时效性，安全性，域名目录....

  * （cookie 单个 value 大小 4k，同一个域名下cookie 40 个左右）
  * 基于 GMT 格林威治时间进行设置

* cookie 在没过期的情况下，会自动携带到服务器端

* session是基于cookie的

  注意：cookie 的时效性一般是后端设置的，前端设置的意义不明显，一般我们在做登录的时候，要做免密码登录，我们会设置一下 cookie 的时效性



localStorage

* 客户端存储技术
* 持久存储
  * 用户手动调用 api 移除
  * 手动清空浏览器
* 大小一般没有太多的限制
* 一般我们的 token 都是存储在 localStorage 中



sessionStorage

* 客户端存储
* 基于会话存储
  * 用户关闭浏览器就会失效
* 大小一般没有太多的限制
* token 也可以存在sessionStorage，但是关闭浏览器就会没有了





## 将对象转为 json 字符串并解析



考点：序列化和反序列化



我们使用 locaStorage.setItem('name', list) ，这里的 list 是一个对象数组，这时存储时，会默认执行 toString() 方法把我们的 list 转化为字符串，但是对象进行 toString() 方法之后会变成 [Object Object] 这种格式，而不是我们期望的格式，这时就需要用到我们的 JSON.stringfy() 和 JSON.parse()



我们要实现上述功能就需要 JSON.stringfy(list) 来进行转化，这样就和预期一样了

我们使用的时候也要需要进行反序列化：JSON.parse(list) / eval(list) 两种方法都行



JSON.parse() JSON.stringfy() 方法存在兼容性问题，低版本浏览器可以使用插件 json2.js





## v-for 中 key 的理解



考点：虚拟dom

key 是虚拟 dom 的唯一标识

首次：使用 v-for 做循环遍历的时候，根据数据生成一份 虚拟dom，然后在 虚拟DOM 转换为 真实DOM 更新到页面

当数据发生改变则会生成新的 虚拟DOM

后面会拿新生成的虚拟DOM和首次的虚拟DOM做比较，底层使用的Diff算法

新的虚拟DOM的key值和首次的虚拟key值做比较

key值一致：继续比较内容，如果内容没有变化，则直接复用之前的真实DOM。如果内容变化了，则生成新的虚拟DOM，替换之前老的 DOM 节点

key值不一致：直接生成新的虚拟DOM，转换为真实的DOM



为什么使用虚拟DOM

主要就是为了实现dom 的复用，我们在开发的时候，dom创建是非常消耗性能的。传统的操作，当数据变化后，都是重新生成dom结构，然后再append到dom树进行重新的渲染。

虚拟dom的出现使得dom结构最大程度实现复用，减少dom的创建和渲染，提升性能。





## vue的组件通信



父>子：属性传递

子>父：自定义事件



兄弟：eventBus



最终的解决方案：vuex



## 谈谈对vuex的理解





vuex是一种集中化处理数据的方案

vuex和vuejs搭配来解决组件之间的通信问题

使用分为

* 同步：mutations
* 异步：actions





